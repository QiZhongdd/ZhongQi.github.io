---
layout: post
title: 宏观视角下的浏览器（3）
subtitle: 输入一个URL会发生什么
date: 2020-12-09
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - 浏览器
---

# 从浏览器的进程看输入URL发生了什么

- 浏览器进程接受到url后会处理输入的信息然后发送给网络进程
- 网络进程收到url后便会发起url请求
- 收到响应后网络进程收到响应头数据后解析并传给浏览器进程
- 浏览器进程收到网络进程的响应头数据后，发送“提交导航”信号到渲染进程
- 渲染进程收到“提交导航消息后”开始接受html数据，接受数据的方式是直接与网络进程建立数据管道
- 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程‘已经准备好解析数据了“
- 浏览器进程收到渲染进程的”确认提交信号“后开始，开始移除旧的文档，显示新的界面

**用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。**

  ![Image text](/img/92d73c75308e50d5c06ad44612bcb45d.webp)

# 从输入 URL 到页面展示

**用户输入**

用户在输入后会判断输入的内容时搜索的内容还是请求的URL
- 如果是搜索的内容，那么地址栏会使用默认的搜索引擎，来合成带关键字的URL
- 如果判断输入的为符合规则的URL，那么地址栏会根据规则把这段内容加上协议合成完整的URL

当用户输入关键字并回车后意味着当前页面会被替换成新的界面，这个时候会给当前页面执行beforeUnload的事件机会，beforeUnload事件允许页面在退出时做一些数据清除的操作，还可以询问用户是否需要离开页面，比如当前页面还有未提交的表单，用户可以通过beforUnload事件取消导航，让浏览器不在进行后面的工作

**请求过程**

浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接

- 构建请求

浏览器构建请求行信息后准备发送网络请求

```

GET /index.html HTTP1.1

```

- 查找缓存

在浏览器发起请求之前会浏览器会在浏览器缓存中查找是否有要请求的文件，如果有缓存那么会拦截该请求，返回该资源的副本，如果缓存查找失败，那么就会进入网络请求。

这里说的缓存是指DNS缓存和http缓存，DNS 缓存主要就是在浏览器本地把对应的 IP 和域名关联起来，http缓存可以参考 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching


- 准备IP地址和端口

IP地址通过DNS解析获取，DNS解析首先会从缓存中查看是否解析过，如果没有那么会从本地操作系统的host中是否有映射，然后查看本地DNS服务器，如果本地的DNS服务器没有，本地的DNS请求根域名的DNS服务器，跟域名服务器会返回主域名服务器所在的IP，本地的DNS再根据主域名IP请求对应的名称服务器的IP地址，然后在请求对应的名称服务器根据映射表获取到目标的IP地址。

http的默认端口号是80，https的默认端口是443

如果协议是https，那么在这个过程还需要建立TLS连接，查看 https://juejin.cn/post/6906126429381984264

- 等待 TCP 队列

端口号和IP地址准备好了后还不能马上建立连接，Chrome有个机制，同一个域名下最大只能建立6个TCP连接，如果在同一个域名下发生10个请求，那么剩余的4个会进入等待状态，只有少于六个请求时才会建立TCP链接

- 建立TCP链接

TCP的连接主要是通过三次握手机制。建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态（半连接），等待服务器确认； 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN+ACK包，此时服务器进入SYN_RECV状态（半连接）。客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手，建立连接。

- 发送http请求

建立连接后，浏览器会向服务端发送请求行、请求头、请求体。

![Image text](/img/b8993c73f7b60feb9b8bd147545c47d7.webp)

**服务器端处理 HTTP 请求流程**

- 返回请求

一旦服务器处理请求完毕，那么首先会返回响应头，响应头包括协议版本和状态码，然后返回响应头和响应体，浏览器会根据响应头的content-type字段去决定如何显示内容，如果是text/html表示html内容，如果是application/octep-stream那么浏览器的下载管理器会进行下载，导航流程接受。

![Image text](/img/3e30476a4bbda49fd7cd4fd0ea09f076.webp)

- 断开连接

一旦服务器发送数据完毕后就会断开连接，断开连接采用四次挥手的机制。
- - 断开连接时，主动方会向被动方发送一个带有FIN附加标记的报文段（FIN表示英文finish，主动方进入半关闭状态（FIN_WAIT_1）。
- - 被动方收到FIN标记的报文段后，不会马上断开连接，首先会发送一个ACK包给客户端，同时通知自己的应用程序对方要关闭连接了，进入close_wait状态。
- - 被动方向客户端发送一个带FIN的报文，进入close状态。
- - 主动方收到被动方发起的FIN报头后，进入time_wait状态，等待2MSL的时间进入到closed状态，释放套接字资源。释放前向被动方发起一个ack包，表示彻底释放。

如果浏览器或者服务器在其头信息中加入了：

```
Connection:Keep-Alive

```
那么TCP会保持连接，可以省去下次请求重新连接的时间，提升资源的加载速度

- 重定向

如果状态码返回的是301或者302，那么会进行重定向


![Image text](/img/1b49976aca2c700883d48d927f48986c.webp)


**渲染模块**

- 构建DOM树

获取到html文本后，浏览器的html解析器将html解析成DOM树。DOM树跟HTML内容几乎相同，但DOM树是保存在内存中的树状解构，可以用js查询或者修改。

- 样式计算

当渲染引擎收到css文件后，会执行一个转换的操作，将css转换成stylesheet,然后进行标准话操作，所谓的标准话就是将所有值转换为渲染引擎可以理解、标准化计算的值。最后会计算出DOM树每个节点的样式属性，在计算的过程中需要遵循两个规则：

- - 继承规则： css子节点会继承父节点的某些属性，比如font-size、font-weight、color等，同时css的样式还有可能来自宇useragent样式，所谓的useragent样式是指浏览器自带的样式。

- - 样式层叠： 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。

![Image text](/img/1252c6d3c1a51714606daa6bdad3a560.webp)


- 生成布局树

有些元素是不可见的，比如head以及display:none的元素在显示之前，会创建可见的布局树，主要完成了以下的操作。
- - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中。
- - 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

![Image text](/img/8e48b77dd48bdc509958e73b9935710e.webp)

- 布局计算

计算每个元素的几何坐标位置，并将这些信息保存在布局树中。

- 分层

有了布局树和计算完相关的布局后，还要进行分层，页面中有许多复杂的效果，比如3D转换、页面的滚动、或者使用z-index做z轴的排序，为了实现这些效果，渲染引擎会专门生成对应的图层，并生成一颗图层树（可以在chrome的开发者工具的layer查看相关的图层）。所以浏览器的页面实际被分成了很多图层，叠加在一起就得到了最后展示的效果。
![Image text](/img/e2c917edf5119cddfbec9481372f8fc0.webp)

但并不是每一个布局树的节点都有一个图层，生成图层得满足以下的条件

- - 拥有层叠上下文属性的元素会被提升为单独的一层。明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。

- - 需要剪裁（clip）的地方也会被创建为图层，如果出现滚动条，滚动条也会被提升为单独的层。

![Image text](/img/e8a7e60a2a08e05239456284d2aa4061.webp)


- 图层的绘制

渲染引擎会把图层分绘制拆封成很多小的指令，然后在把这些很小的指令生成待绘制的列表，用于绘制的顺序。

![Image text](/img/40825a55214a7990bba6b9bec6e54108.webp)

- 栅格化（raster）操作

绘制列表是用来记录绘制顺序和绘制指令的列表，而实际上的绘制操作是由渲染引擎的合成线程来完成的。主线程会把绘制列表提交给合成线程。

![Image text](/img/46d33b6e5fca889ecbfab4516c80a441.webp)


> 视图是用户可见的区域，有的图层很大，通过视口只能看到图层的一小部分，在这种情况下，如果要绘制整个图层，就会产生大的开销，完全没有必要，所以合成线程会将图层划分成图快

![Image text](/img/bcc7f6983d5ece8e2dd716f431d0e052.webp)

然后合成线程会将这些图层绘制成图块，将视口附近的图快优先生成位图,生成位图的操作是由栅格化来执行的。所谓的栅格化是将图快转换为位图。图快是栅格化的最小单位，渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

![Image text](/img/d8d77356211e12b47bb9f508e2db8520.webp)

通常栅格化的还会使用到gpu加速完成，使用gpu加速的栅格化叫快速栅格化，或者gpu栅格化。而gpu操作是在gpu进程中运行的，生成的位图被保存在 GPU 内存中，代所有图块完成光栅化后，将结果返回给合成线程。所以这就涉及到了跨进程的处理。

![Image text](/img/a8d954cd8e4722ee03d14afaa14c3987.webp)


- 合成显示

一旦所有的图快都完成了栅格化，合成线程就会生成一个“DrawQuad”绘制图层的指令，然后将该指令提交给浏览器进程的viz组件，然后浏览器进程会根据drawquad指令将页面内容绘制到内存中显示。


# 总结- 用户输入url发生了什么

- 首先如果用户输入的是符合URL规则的字段，那么会带上协议合成完成的URL，替换成新的界面。如果不符合，那么会采用默认的搜索引擎带关键字合成URL进行搜索

- 浏览器发起http请求过程，构建请求行发送信息

- 请求缓存，缓存主要是DNS缓存和Http缓存

- 获取IP地址和端口号，运用DNS获取IP地址，http协议默认80端口、https协议默认443端口。如果是https协议，那么这个阶段还会进行TLS握手

- 等待TCP队列

- 使用TCP三次握手进行连接

- 发送http请求，发送的内容包括请求行、请求头、请求体

- 响应请求，响应的内容包括响应行、响应头、响应体。浏览器根据content-type去显示不同格式的内容

- 如果没有设置keep-alive，那么会用四次挥手进行断开连接

- 如果状态码是302或者是301那么会进行重定向。

- 获取到html内容后，准备渲染进程继续渲染，首先会交给html解析器进行解析,生成DOM树

- 渲染引擎收到css后会进行样式计算生成stylesheet，样式计算遵循继承和层叠计算的原则。

- 生成布局树，遍历DOM树，将dom树的节点添加到布局树中，不可见的元素会被忽略

- 生成布局树后，那么会计算布局信息。

- 进行分层，生成layer Tree，css有许多复杂的3D效果或者使用z-index进行做z轴的排序，所以会生成图层树。

- 进行图层的绘制，渲染引擎会把图层拆分成很多小的指令生成待绘制的列表，用于控制绘制的顺序

- 将待绘制的列表和图层提交给合成线程

- 合成线程会将图层划分成图块，进行栅格化操作，所谓的栅格化就是将图块生成位图。渲染进程维护了一个栅格化线程池，栅格化就是在这线程池操作

- 现代浏览器栅格化时都使用了GPU加速，所以最终生成位图的操作都在GPU上操作，这就涉及到了跨进程的操作，栅格化完成的位图都会缓存到gpu内存中，待光栅化完成后将结果返回给合成线程

- 等所有的图块都栅格化完成后那么就会生成DrawQuad指令

- 合成线程会将DrawQuad指令提交给浏览器进程的viz组件

- 浏览器将DrawQuad指令保存在内存中，用户显示在屏幕上




# 其他

**css和js都会阻止dom的解析**

```
当从服务器接收HTML页面的第一批数据时，DOM解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：
<html>
    <body>
        极客时间
        <script>
        document.write("--foo")
        </script>
    </body>
</html>
那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下解析。

那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：
<html>
    <body>
        极客时间
        <script type="text/javascript" src="foo.js"></script>
    </body>
</html>
这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM渲染。

我们再看第三种情况，还是看下面代码：
<html>
    <head>
        <style type="text/css" src = "theme.css" />
    </head>
    <body>
        <p>极客时间</p>
        <script>
            let e = document.getElementsByTagName('p')[0]
            e.style.color = 'blue'
        </script>
    </body>
</html>

当我在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。


所以JS和CSS都有可能会阻塞DOM解析

```

**减少重绘重排的操作**

```
1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离
6. will-change: transform 做优化

```

**渲染进程**

```
1:首先渲染进程里执行图层合成(Layer Compositor)，也就是生成图层的操作，具体地讲，渲染进程的合成线程接收到图层的绘制消息时，会通过光栅化线程池将其提交给GPU进程，在GPU进程中执行光栅化操作，执行完成，再将结果返回给渲染进程的合成线程，执行合成图层操作！

2:合成的图层会被提交给浏览器进程，浏览器进程里会执行显示合成(Display Compositor)，也就是将所有的图层合成为可以显示的页面图片。 最终显示器显示的就是浏览器进程中合成的页面图片

```

**如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？**

```
1 首先猜测最可能的出问题的地方，网络传输丢包比较严重，需要不断重传。然后通过ping curl看看对应的时延高不高。
2 然后通过wireshake看看具体哪里出了问题。
3 假如别人访问很快，自己电脑很慢，就要看看自己客户端是否有问题了。

4使用 chrome network 面板，看那个 瀑布图 中每个阶段的含义，就可以判断问题出现在那个方向了，每个阶段的含义，https://developers.google.com/web/tools/chrome-devtools/network/reference#timing-explanation 举个例子 Content Download 如果太长，很有可能是下载的资源太大，但也有可能是网络慢导致的下载太慢，简单计算一下，在例如 Waiting (TTFB) 这个太长的话，有可能是网络慢，或者就是 后端处理时间过长导致的，至少可以排查掉前端原因，还有很多，例如 DNS lookup 等，但是最终要确认具体哪里慢，最好是结合系统日志去分析


```

css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。

JavaScript都是在在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣！










