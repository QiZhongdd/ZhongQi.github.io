**常见状态码：**
200请求成功并正常处理
204,noContent，只会返回头信息
206：表示客户端发起了范围请求，并且服务器成功执行了get请求，响应报文中包含了Content-range范围请求
301：永久性重定向
302暂时性重定向
303表示请求资源换了地方，必须使用get定向请求资源，与302相比，303明确使用get方法
304协商缓存状态
400表示请求报文中存在错误
401未经许可，需要http认证
403服务端禁止访问
404路径错误
特殊状态码：413：请求实体过大，超过了服务器能够处理请求的范围。一般是在上传文件的时候才会出现。可以配置nginx的client-max-body-size。
500请求服务端时出现错误
502状态码是服务器（不一定是Web服务器）作为网关或代理，以满足客户的要求来访问所请求的URL 。 此服务器从上游服务器收到无效响应.
503服务端超负荷或正在维护，无法处理
504：服务器作为网关或者代理服务器向上游发起请求时，未能及时响应.504一般都是和nginx的配置有关。比如nginx设置了超时时间，当在超时时间内没有收到请求就会给客户端返回504


http：在http0.9的时候http只能发送get请求，并且只能响应Html字符串，服务器发送完毕后Tcp就会断开。在http1.0的时候，不仅可以传输文字，还可以传输图像、视频，二进制等，同时还引进了get、post、head请求。请求信息和响应信息也发生了改变，除了数据以外，还有头信息。但http1.0缺点是每个Tcp只能发送一个请求，发送完毕TCP就关闭，为了解决这问题，就出现了非标准字段connection:keep-alive。在http1.1的时候引入了持久链接，不用再标明connection:keep-alive就可持久化链接，当客户端和服务端发现对方一段时间没有活动，就主动关闭。对于同一个域名大多数浏览器只支持连接6个持久化链接。并且Http1.1还引入了管道机制，所谓的管道机制就是只在同一个TCP连接里面能发送多个http请求，但是服务器还是按顺序响应，如果一个请求阻塞，后面的请求都会阻塞，这样就会造成对头堵塞。同时在http1.1一个tcp可以传输多个响应，为了区分数据包属于哪个响应，使用了content-length标识信息。http1.1还支持流式传输，通过设置Transfer-Encoding: chunked就可以支持流式传输。并且添加PUT、PATCH、HEAD、 OPTIONS、DELETE等请求方法。


htt2采用了二进制帧的形式对数据进行处理，头信息和数据体都是二进制，称为头信息帧和数据帧。同时http2采用多路复用的形式进行传输。所谓的多路复用是指多个请求共用一个TCP，将一个TCP分成若干个数据流，每个数据流都有一个唯一的标识符，消息由二进制帧组成。帧是最小的通信单位，承载着特定类型的数据，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装，这样就避免了对头堵塞。并且http2中，服务端可以在客户端发起请求后，主动推送其他资源。虽然 HTTP/2 解决了很多之前旧版本的问题，因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，整个 TCP 都要开始等待重传，也就导致了所有数据都被阻塞了。这个问题并不是它本身造成的，而是底层支撑的 TCP 协议的问题



# TCP和UDP的区别
- TCP是面向连接的，而UDP是无连接的，及不用连接也可以传输数据
- TCP采用字节流的形式传输数据，而udp采用报文的形式传输数据，不受阻塞控制
- TCP是点对点的，而UDP可以多对多、一对一、一对多
- TCP是的首部开销是20字节，而udp的首部开销较小，只有8字节
- TCP提供可靠的服务，保证传输的数据无差错、无重复、有序的。而udp不能完全保证数据的准确性

http3是使用QUIC作为底层协议，而QUIC又依赖于UDP，他除了有UDP的优点以为，还实现了多路复用、TLS1.3加密、ORTT、向前纠错机制等。多路复用跟http2类似，将QUIC分成多个stream，但每个strem是互不干扰的，如果一个strem出现了丢包，并不会干扰其他strem的传输。同时QUIC在移动端复杂网络的表现更加良好，tcp是通过ip和端口号进行识别和连接，如果一旦断开，那么就会重新识别相关的端口和ip,而quic是基于一个ID识别的，只要ID没有变就能快速重连，传输数据那么就是0rtt。http3还会对数据进行严格加密，只要发现报文有任何修改，那么接收方就能立刻发现。除此之外，quic还实现了向前纠错机制，所谓的详情纠错机制是指是指每个数据包还有其他数据包的冗余数据，如果一个数据包丢失了，那么可以通过其他数据包推算出丢失的数据，这样就不用进行重新发送了


TLS 1.3 与之前的协议有较大差异，主要在于：

相比过去的的版本，引入了新的密钥协商机制,PSK，不再是之前的非对称加密和对称加密
支持 0-RTT 数据传输，在建立连接时节省了往返时间
废弃了一些不安全的加密算法
ServerHello 之后的所有握手消息采取了加密操作，可见明文大大减少
不再允许对加密报文进行压缩、不再允许双方发起重协商
DSA 证书不再允许在 TLS 1.3 中使用

# TCP如何保证数据的有效性
- 校验和：tcp将传输的二进制进行取反求和，验证数据在传输时是否有更改，如果有那么就丢弃这个数据包并确认这个包丢失
- 确认应答+序列号：TCP在传输数据的时候首先会对数据包进行编号，接收端收到数据后会根据序列号进行排列
- 超时重传：TCP传输数据时，会创建一个计时器，如果接收端没有及时接受，那么就会自动重传
- 流量控制：接收端和发送端都有一个滑动窗口用来控制发送数据和接受数据的大小，接受端只允许发送端发送缓冲区间大小的数据。当接收方不能及时处理数据，那么会通知发送方降低传输速率
- 拥塞控制：当网络拥塞时，会减少数据的发送



# 五层网络体系
应用层：应用层是发起通讯的地方，一般是浏览器、email等
传输层：传输层建立网络链接，比如TCP用来建立可靠的链接、UDP用来建立快速的链接
网络层：传输层将数据进行打包，并将数据包进行传输
数据链路层：数据链路层创建帧，帧中包含数据包，同时将帧传入给物理层
物理层：物理层将帧进行解码，得到数据


# tcp:三次握手

第一次握手，客户端发送syn(syn=j)到服务器，并进入syn_sent的状态，等到服务器确认
第二次握手：服务器收到syn报文，必须确认客户端的syn,同时自己发送一个syn+ack包，此时服务器进入syn_receive状态
第三次握手：客户端收到syn+ack报文后，向服务端发送一个ack报文（ack=k+1）,此包发送完毕，服务端和客户端进入establish状态

**syn是握手信号，ack是握手信号**

# tcp:四次挥手
- 不管是客户端还是服务端都可以主动发起断开，当断开连接时，主动方会向被动方发送一个FIN报文段，主动方进入FIN_WAIT_1状态。
- 被动方收到FIN标记的报文段后，不会马上断开连接，首先会发送一个ACK包给主动方，通知对方自己的应用程序的要关闭连接了，进入close_wait状态，主动方收到ack报文后进入FIN_WAIT-2状态，这时主动方已经没有数据要发送了，但是被动方若发送数据，主动方依然要接受。。
- 被动方向主动方发送一个带FIN+ack的报文，LAST-ACK（最后确认）状态。
- 主动方收到被动方发起的FIN报头后，必须发出确认的ack报文，进入time_wait状态，它是主动关闭的一方，在回复完对方的挥手后，此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间，双方才会CLOSED状态


# 为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？
第一，保证主动方发送的最后一个ACK报文能够到达被动方，因为这个ACK报文可能丢失，站在被动方的角度看来，我已经发送了FIN+ACK报文请求断开了，主动方还没有给我回应，应该是我发送的请求断开报文它没有收到，于是被动方又会重新发送一次，而主动方就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，主动方发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文




# https的过程

客户端首先向服务端发送支持的SSL/TSL版本、加密算法、压缩方法集合给服务端，服务端收到后会确定双方都支持的TLS版本、加密算法、压缩方法集合，然后服务端发送证书给客户端，如果选择了双向认证，那么服务端会向客户端请求发送证书，服务端通知客户端协商结束。如果选择了双向认证，那么客户端会发送自己的证书给服务端。客户端在收到证书后，会用hash算法对证书进行验证，如果验证成功，客户端使用证书的公钥，对客户端公钥和密钥种子进行加密发送给服务器端。如果选择双向验证，客户端用本地私钥生成数字签名，并发送给服务器端，让其通过收到的客户端公钥进行身份验证。服务端用私钥进行解密获取到客户端的公钥和秘钥种子。通讯双方基于密钥种子等信息生成通讯密钥，客户端通知服务器端已将通讯方式切换到加密模式。客户端做好加密通讯的准备。服务器端通知客户端已将通讯方式切换到加密模式。,服务器做好加密通讯的准备。对通讯内容进行加密传输，通讯结束后，任何一方发出断开 SSL 连接的消息。

https传输内容采用非对称加密、对称加密相结合的方式，



# http的请求体和响应体部分
请求体包括请求行、请求头、请求数据，空行、请求行包括请求方法、url、host，请求头包括user-agent,accept、content-type等。空行包括换行符和回车符，通知服务器以下不再有请求头。
响应体包括响应行，响应行包括状态码、原因、ip地址。响应头、响应数据

restful风格api特点：协议使用https、域名在专有协议下、将版本放入url中、路径只能是名词、利用动词进行相关的操作，所谓的动作就是请求方式。


**dns**
IP地址通过DNS解析获取，DNS解析首先会从缓存中查看是否解析过，如果没有那么会从本地操作系统的host中是否有映射，然后查看localDNS服务器，如果localDNS服务器没有，localDNS请求根域名的DNS服务器，跟域名服务器会返回主域名服务器所在的IP，localDNS再根据主域名IP请求对应的name server服务器的IP地址，然后在请求对应的name server服务器根据映射表获取到目标的IP地址。

**CDN访问流程：**

所谓的cdn简称为内容分发网络，它的作用将内容保存在离用户较近的网络边缘节点上，从而提高访问速度。
cdn的解析主要有以下几个步骤，在没有缓存的情况下，首先会向localDns发起域名解析请求，localDns会向根域名服务器发起请求，根域名服务器会返回授权服务器所在的地址，localDns会向域名授权服务器发起请求，域名授权服务器会返回域名记录，一般是CNAME,所谓的CNAME一般是指能根据一个域名获取到ip。获取到域名记录后，智能DNS会根据自己的算法和策略去解析最适合用户cdn节点的ip返回给localDns，localDns会返回给用户，然后发起请求获取地址。简单点说就是通过修改dns解析，通过dns引导用户到cache服务器获取资源，加快请求速度。整个过程最重要的设备就是智能DNS,他能根据自己的算法和策略获取到最适合的cdn节点，同时能够与每个cdn节点保持联系，获取cdn的压力和相关的状态信息。


# 中间人攻击
客户端发起请求被中间人服务器劫持，中间人服务器会返回自己的证书给客户端。客户端在收到证书后首先会创建随机数，然后用证书中的公钥对随机数加密，同时用随机数对传输内容进行加密后，随机数和传输内容会一起发给中间人服务器，中间人服务器对随机数进行解密，获取到随机数后再对传输内容进行解密，这样中间人就可以查看或者篡改内容。收到内容后，中间人会把内容发送给服务器，中间人和服务端的请求是合法的，所以服务端会将响应内容返回给中间人。由于中间人与服务端建立了对称加密，所以可以对响应内容进行查看，最后中间人在把响应内容返回给客户端

由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。所以需要对证书进行合法的验证

安全：

xss跨站脚本攻击，分为存储性xss、反射性xss、dom形xss。存储性xss是指恶意代码被存入数据库中，等到用户打开网站的时候会获取恶意代码，恶意代码会被执行，然后执行一些恶意的操作，反射性xss是指恶意代码保存在url中，当获取url时，恶意代码会在浏览器中执行。DOM XSS不需要服务端参与，可以认为是前端代码漏洞导致。比如利用eval执行恶意的代码。防御手段主要有以下几种，对输入的一些特殊符号进行转义、对输入的数据进行简单的验证，配置csp content-security-policy:default-src

csrf：跨站请求伪造。攻击者引导用户进入第三方网站，在第三方网站向攻击网站发起请求，利用用户在攻击网站获得的凭证，绕过后端的验证，冒充用户执行恶意操作。预防利用header头origin(请求站点的信息)和refer（告诉服务器是从那个时候页面发起请求的）进行验证、配置csrf token

sql注入：是指web应用程序对用户输入数据的合法性没有判断或过滤不严。攻击者可以在web端事先定义好查询语句的结尾上添加sql语句，在管理员不知道的情况下执行恶意操作，以此实现获取数据库的信息



