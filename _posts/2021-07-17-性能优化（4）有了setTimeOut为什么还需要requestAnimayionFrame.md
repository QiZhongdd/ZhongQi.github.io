layout: post
title: 性能优化（4）-有了 setTimeOut 为什么还要有 requestAnimationFrame
subtitle: 有了 setTimeOut 为什么还要有 requestAnimationFrame
date: 2021-07-16
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:

- 性能优化

---

# 浏览器消息队列的迭代

首先我们分析了基于单消息队列会引起队头阻塞的问题，为了解决队头阻塞问题，我们引入了多个不同优级的消息队列，并将紧急的任务添加到高优先级队列，不过大多数任务需要保持其相对执行顺序，如果将用户输入的消息或者合成消息添加进多个不同优先级的队列中，那么这种任务的相对执行顺序就会被打乱，所以我们又迭代了第二个版本。在第二个版本中，按照不同的任务类型来划分任务优先级，不过由于采用的静态优先级策略，对于其他一些场景，这种静态调度的策略并不是太适合，所以接下来，我们又迭代了第三版。第三个版本，基于不同的场景来动态调整消息队列的优先级，到了这里已经非常完美了，不过依然存在着任务饿死的问题，为了解决任务饿死的问题，我们给每个队列一个权重，如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样我们就完成了 Chromium 的任务改造。

# 页面为什么会造成丢帧和卡顿

显示器会以每秒 60HZ 的频率从前缓存区读取图像显示。浏览器会将生成图像提交到显卡的后缓存区，待浏览器将图像提交后,当显示器读取完一帧后，在开始下一帧之前会发送一个信号（VSync）给 GPU 会将后缓存区变成前缓存区，显示器读取图片显示。但**VSync 和系统的时钟不同步就会造成掉帧、卡顿、不连贯等问题**。

![Image text](/img/1c3a9d8a0f56b73331041ea603ad3738.webp)

- 如果渲染进程生成的帧速率实际上比屏幕刷新率快，那 GPU 所渲染的图像并不会全部显示出来，那么就会造成丢帧
- 如果显示器读取的帧率快于浏览器，那么就会造成卡顿。
- 就算屏幕的刷新频率和 GPU 更新图片的频率一样，由于它们是两个不同的系统，所以屏幕生成帧的周期和 VSync 的周期也是很难同步起来的。

![Image text](/img/06206ed4846e9531351a0cb7d1db6208.webp)

# window.requestIdleCallback()

VSync 同步周期是 16.66（1/60）毫秒，gpu 每接收一个 vsync 信号代表着进入下一帧。合成线程会提交给渲染主线程提交完成合成的消息。如何合成的速度非常快，比如用来 8ms，但发送下一个 vsync 的信号是 16.66ms，这样渲染主线程就会有一段空闲的时间，那么就可以在这段空闲时间内执行一些不那么紧急的任务，比如 V8 的垃圾回收，或者通过 window.requestIdleCallback 设置的回调任务等。

# window.requestAnimation()

css 的动画是跟浏览器的渲染流程处理的，所以渲染进程会让 CSS 渲染每帧动画的过程与 VSync 的时钟保持一致, 这样就能保证 CSS 动画的高效率执行。

但 js 是由用户手动控制的，如果采用 setTimeout 来触发动画每帧的绘制，那么其绘制时机是很难和 VSync 时钟保持一致的，所以 JavaScript 中又引入了 window.requestAnimationFrame，用来和 VSync 的时钟周期同步。
应该说 raf 的回调任务会在每一帧的开始执行
