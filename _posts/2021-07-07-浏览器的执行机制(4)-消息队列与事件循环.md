---
layout: post
title: 浏览器中js的执行机制
subtitle: js是如何保存内存
date: 2020-12-09
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - 浏览器
---

# 简介

渲染进程只有一个主线程、这个线程要负责各个线程的调度，js任务的执行、ui的渲染等，要让这些任务顺利的执行就需要有一个统筹调度的机制**时间循环与消息队列**

# 线程处理任务总结

- 如果有确定好的任务并且可以让单线程按顺序执行，这是第一版的线程模型
- 第一版线程的模型有个缺点就是执行的时候如果其他线程传入了一个任务，那么这个任务就不会执行。为了解决这个问题，引入了事件循环（事件循环可以看成一个for循环，如果有新任务进来会暂停执行），循环一次结束时会判断是否有任务进来，如果没有那么就结束事件循环，如果有那么就继续下一次循环，在下一次循环的时候执行该任务。这是第二版的线程模型

- 如果要接受其他的线程（IO线程）传入进来的任务，就需要用消息队列去进行接收。这是第三版的线程模型

- 如果有其他进程的任务，那么首先会通过IPC协议将任务传给IO线程，然后再传输给消息队列

- 如果在执行消息队列的任务有优先级较高的任务，那么首先会将该优先级较高的任务添加到一个任务队列，待正在执行的任务执行完后，再将任务队列中的任务提取出来一一执行。这也就是宏任务和微任务机制，**存放在消息队列中的任务称为宏任务，任务队列中的为微任务**

![Image text](/img/e2582e980632fd2df5043f81a11461c6.webp)

# setTimeOut

在消息队列中的任务都是按顺序执行，但通过定时器设置的回调函数需要在一端时间后才能执行，为了保证这些事件定时执行，chrome还维护了一个延迟事件队列去存放这些任务，在每一次循环处理完消息队列中的任务后都会调用ProcessDelayTask去判断有没到期的任务，如果有的话就执行，然后进入下一个循环。

```

void ProcessTimerTask(){
  //从delayed_incoming_queue中取出已经到期的定时器任务
  //依次执行这些任务
}

TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainTherad(){
  for(;;){
    //执行消息队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    
    //执行延迟队列中的任务
    ProcessDelayTask()

    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}

```
**使用setTimeOut应该注意什么**

- setTimeOut嵌套超过5次，后面的setTimeout使用每个setTimeout会间隔4ms，这是因为chrome会判断该函数被阻塞了。
- 如果定时器之前执行的任务太长了，那么会影响当前定时器的执行，比如设置了500ms，它可能超过500ms才会执行
- 未激活的页码，setTimeout执行的最小时间是1000。比如打开打开一个tab，不等它加载完成，在去打开另一个tab，那么之前的tab页的定时器最小时间为1000，目的是为了优化后台加载的损耗和降低耗电量。
- 定时器是有最大时间的，chrome、firfox用32bit存储时间,存储的时间最大时间为2147483647ms（大约24.8天），超过会溢出，相当于设置成0
- 使用setTimeOut推迟执行对象里面的方法，那么这个方法中的this指向全局

```


var name= 1;
var MyObj = {
  name: 2,
  showName: function(){
    console.log(this.name);
  }
}
setTimeout(MyObj.showName,1000)

```
可以放在箭头函数或者匿名函数里面，还可以通过bind去解决这个问题

```

//箭头函数
setTimeout(() => {
    MyObj.showName()
}, 1000);
//或者function函数
setTimeout(function() {
  MyObj.showName(); 
}, 1000)

setTimeout(MyObj.showName.bind(MyObj), 1000)

```

# XMLHttpRequest

XMLHttpRequest是渲染进程通过IPC与网络进程通信，通知网络进程发送一个请求，网络进程收到响应后会以IPC的形式通知渲染进程的IO线程，将对应的消息添加到消息队列中，

# 宏任务和微任务

宏任务是消息队列中的任务，缺点是在时效性比较差，因为每个宏任务下面有一堆子任务，待这些子任务执行完成后才会进入下一个循环。息队列中这种粗时间颗粒度的任务已经不能胜任部分领域的需求，所以又出现了一种新的技术——微任务。**微任务可以在实时性和效率之间做一个有效的权衡。**

**宏任务**

宏任务包括以下几种：

- 渲染事件（如解析 DOM、计算布局、绘制）
- 用户的交互
- setTimeOut
- JavaScript 脚本执行事件
- 网路请求完成、文件对的读写

像这些任务都是由系统添加到消息队列中的，js是不能控制任务的顺序，所以很难控制这些任务的执行时间，同时宏任务的跨度之间可能还有系统级的任务执行，所以宏任务的时间粒度比较大，执行时间不能精确控制，对一些高实时性的任务就不能满足了，比如监听dom的变化，所以后来就出现了微任务

**微任务**

微任务是一个需要异步执行的函数，在主函数执行完后当前宏任务结束之前执行。js在执行的时候首先会创建一个全局的执行上下文，同时在全局的上线文设置一个微任务队列用来存储微任务，这个微任务是是给V8引擎内部使用的，所以js是无法访问的。浏览器产生微任务有两种方式:

- 调用Promise.resolve、promise.reject的时候
- MutationObserver监控dom节点的变化，当dom节点发生变化就会产生dom变化的微任务

> 通常情况下在当前宏任务块结束完，也就是js准备退出全局上下文并清空调用栈的时候，js会检查全局上下文中的微任务队列是否有任务，如果有的话那么就会一一执行。同时如果在一个微任务中产生了新的微任务，那么该微任务也会添加到微任务对流中，在当前宏任务中执行。等任务队列清空了才会进入下一个任务

![Image text](/img/1db319c879610816c0cfea22723fc492.webp)

**微任务和宏任务总结**

- 一个宏任务对应一个微任务队列，每个宏任务执行都会创建自己的微任务队列
- 微任务的执行时长会影响到宏任务的执行时长，比如一个宏任务里面有100个微任务，每个微任务执行10ms,那么这个宏任务至少需要1s，所以宏任务的时间颗粒度比较大，无法做及时性要求高的任务，比如监听dom。
- 在一个宏任务中，创建的微任务的执行永远优先于创建的宏任务

# MutationObserver

MutationObserver主要用来监听dom的变化，包括属性的变化、节点的增减、内容的变化等。MutationObserver **采用了“异步 + 微任务”的策略。**
- 异步解决了同步操作的问题，等多次dom变化后一次性触发。
- 微任务解决了时效性的问题







