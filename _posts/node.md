# node性能测试

上线之前首先要压力测试配合linux命令找到性能瓶颈，然后进行node性能分析，进行优化。上线后要进行监控，如果出现异常要报警。

**压力测试配合linux命令找到性能瓶颈**
压力测试可以使用webbench和ab,重点关注qps和吞吐量，如果吞吐量与网卡的吞吐量想吐，那么瓶颈就是在网卡，如果不是那么可能就是cpu、内存、硬盘,可以在压测的时候使用linux的top命令去查看内存和cpu的占用，硬盘可以使用iostat用来查看，iostat是用来io设备的带宽，还有一个性能瓶颈是在后端服务器上，假如node层的吞吐量大于服务端的吞吐量，那么瓶颈就是服务端。通常瓶颈是node层cpu运算能力上，比如做一些字符串的js运算都有可能成为性能瓶颈，这体现在cpu占用100%或者机器的负载达到了100%。如果是node层的问题那么可能就是某一段代码写的不够好，浪费了大量的性能。所以需要找到哪一段代码消耗了大量的性能。

**Node性能分析**


Node自带性能分析工具profile，根据profile生成的log可以查看到js运算以及c++运算的耗时、重点需要关注heavy botton up，该栏是按调用栈来划分的，能看到每一个函数占他父的调用的比例。

也可以用chrome devtool去调试node,因为node跟chrome都是用的v8，在performance中的使用快照可以查看到相关调用栈的耗时，也可以通过ip查看远端服务器的运算情况

clinic可以根据可视化图表查看到事件循环的时间、cpu使用情况、代码每一段调用的耗时。一般使用与大项目


一些案例：
- 避免大量的IO读写，比如每一个请求都进行读写操作，考虑下能不能优化只读写一次
- 使用buffer进行传输，在进行传输渲染的时候不先转换成utf8而是直接进行buffer传输会提高效率，因为传输给body的是字符串，但node的最终还是要将字符串转成buffer传输给c++，最终c++输出去body还是buffer。
  
**内存管理**

新生代容量小，回收快，老生代容量大，回收慢。减少内存使用也是提高性能的手段，如果有内存泄露会导致服务性能大大降低。所以上线时需要检查是否有内存泄露。
也可以使用chorme devtool的快照对比压测时和压测后的内存使用情况，如果压测后的内存大于压测时的内存表示内存泄漏。可以用comparison对比两个快照的情况。

减少内存使用
buffer是node.js自己做的一个对象，不受v8的控制，buffer的分配策略有两种，大于8kb和小于8kb。buffer对应的c++char数组。如果小于8kb的buffer,只会实例化一次char.加入当前定义的buffer为2kb,那么会分配2kb的char给buffer。下次使用小于8kb的buffer不会在实例化char，继续分配一部分给buffer，如果当前的char用完了，那么会在实例化一个char继续分配。在使用期间，如果有一个buffer销毁，在char里面的空间也会释放。


# cluster多进程优化

  
使用cluster启动多个子进程运行多个http服务。fork多个进程意味着会把代码和内存复制一遍，如果占满了cpu，可能会导致事件循环或者其他计算没有做到及时处理。所以不要把进程数与cpu核数相同。pm2的原理就是如此。要对进程进行守护，一旦有个进程失效，可以在一段时间后进行重启。或者可以每隔一段时间给子进程发送消息，看下子进程有没有回复，如果没有回复可能意味着字进程进入假死状态，应该杀掉该进程。

使用多个进程启动多个http服务，意味这端口号相同，正常情况下是会报错的，但cluster模块不会，这是因为启动的其实是主进程，在cluster模块中一旦监听到有新的请求进来，那么会将相关的请求分发给子进程。相当于维护了一个事件池，一旦有子进程空闲，那么会从事件池取出一个事件进行分发。

# 性能优化

性能优化的准则是减少不必要的计算，需要思考的是在用户能感知到的时间能这段代码是不是有必要的，能不能挪到其他地方去运算，或者能不能空间换时间，尽可能挪到程序启动的时候运行。比如模版字符串在启动的时候就进行编译运算，当用户请求的时候将编译好的字符串返回回去。

1.动静分离

node处理静态文件能力并不突出，将图片、字体、样式表和多媒体等静态文件都引导到专业的静态文件服务器上，让node曾只处理动态请求即可。这个过程可以用 nginx 或者专业的cdn 来处理。

2.启用缓存

提升性能其实羞不多只有两个途经，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大是收益越多。避免不必要的计算，应用场景最多的就是缓存。可以使用redis、开启https缓存策略。

3.多进程架构

通过多进程架构,不仅可以充分利用多核cpu, 更是可以建立机制让node 进程更加健壮，可以使用pm2进程管理。

4.代码层的优化

使用新版本的node就能提升性能的提升 每个版本的性能提升来自两个方面v8 的版本更新；node 内部代码的更新优化。

5.使用fast-json-stringify加快json序列化，在json序列化时需要识别大量字段类型，根据不同的字段类型进行不同的操作，如果已经提前通过schema知道每个字段的类型，那么就不需要遍历、识别字段类型，而可以直接用序列化对应的字段，这就大大减少了计算开销，这就是fast-json-stringify 的原理。

6.正确的编写异步代码





# node的性能监控

性能监控主要分为两大类，一类是业务逻辑型的监控，第二种是日志型的监控。
性能监控主要分为以下几种
- 日志监控，可以通过监控日志的异常，将新增异常的数量类型反应出来。监控日志还可以监控pv和uv知道访问高峰
- 响应时间监控：一旦某个子系统异常或者出现性能瓶颈，那么就会导致响应时间的延长，响应时长可以通过nginx反向代理活着自行产生日志进行监控
- 监控进程：监控日志和响应时常都是运行状态，所以监控进程是比前两者更为紧要的任务，监控进程一般是检査操作系统中运行的应用进程数，比如对于采用多进程架构的node应用，就需要检査工作进程的数,如果低于预估值，就应当发出报警。
- 监控磁盘异常：磁盘监控主要是监控磁盘的用量。由于日志频繁写的缘故，磁盘空间渐渐被用光。一且磁盘不够用，将会引发系统的各种问题，给磁盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者就应诙整理日志或清理磁盘。
- 内存监控，正常的内存应该是有升有将的，如果内存只是上升，那么就是出现了内存泄露的状况，可以对内存使用设置一个监控值，一旦内存大过这个值那么意外者出现了内存泄漏。
- 网络监控：但还是需要对流量进行监控并设量上限值。即便应用突然受到用户的青昧，流量暴涨时也能通过数值感知到网站的宣传是否有效，一旦流量超过警戒值，开发者就应当找出流量增长的原因。网络流量监控的两个主要指标是流入流量和流出流量。

# node错误监控

错误分类
- 当语法错误或者运行错误会触发js错误
- 当读写文件发生错误时会出现系统错误
- 除 js 错误和系统错误外，还可以自定义错误。

生成日志可以使用log4j、connect中间件，错误监控平台还可以用sentry。




# koa

**简单实现一个koa**

koa的步骤
- 建立koa类,因为koa是要new使用的。
- 创建app.use，用来注册中间件
- 创建app.lisnter，主要是使用http.createServer进行创建，httpServer会接受一个callback，它是http的回调函数，主要用来处理网络请求。对于一个请求来说，它要穿个一个个中间件，以递归的形式去执行相关的中间件，在执行中间件的时候如果有next函数，那么会创建一个promise，等到下一个中间件执行完毕后才会执行next后面的代码。
- 调用createContext，根据req和res创建ctx这个上下文，req是httpServer的请求描述符，而ctx中的request对req进行了扩展，response和res也是如此。
- ctx创建完毕后，那么就处理相关的请求，将ctx传递给回调函数

**实现一个洋葱模型**

```
function compose(middlewareList){
 return function(ctx,next){
   return dispatch(0)
   function dispatch(i){
     let fn=middlewareList[i];
     if(i===middlewareList.length)fn=next;
     if(!fn)return Promise.resolve();
     return Promise.resolve(fn(ctx,dispatch.bind(i+1)));
   }
 }
}

```

其他实现一个函数式编程compose

```
function compose(func){
  if (funcs.length === 0) {
    return arg => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funs.reverse().reduce((a,b)=>(...args)=>a(b(...args)))
}

```



# 其他

**上传文件content-type用什么类型，文件内容是一次性传过来的吗**

上次文件用的multipart/form-data，文件内容是以stream的形式一点一点传过来的。http模块的createServer的request实现了readableStream接口，这个信息流可以被监听，也可以与其他流进行对接。我们只要在监听data和end对流进行拼接。






