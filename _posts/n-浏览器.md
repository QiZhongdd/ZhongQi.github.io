**浏览器有哪些进程**

- 浏览器进程：主要负责页面的显示、用户交互、子进程管理，同时提供存储的功能
- 渲染进程：核心任务是将 HTML、CSS 和 JS 转换为用户可交互的网页，排版引擎 Blink 和 V8 引擎都都是运行在这，默认情况 Chrome 是一个 tab 一个渲染进程（假如多个 tab 在同一站点（同源），那么共用一个渲染进程，但在a标签跳转的时候添加 rel='noopener',可以不共用进程），处于安全考虑，渲染进程是运行在沙箱下的
- GPU 进程，GPU 主要是为了绘制 UI（渲染交个渲染进程）
- 网络进程用于网络资源的加载
- 插件进程用于运行插件，插件比较容易崩溃。


**输入一个url会发生什么**

- 首先会判断输入的内容是否符合url规则，如果不符合那么搜索引擎会合成url带上关键字进行搜索。符合的话那么会进行跳转。跳转的时候会触发当前节目界面的beforeunload事件，在这个事件中我们可以做一些数据的清除，还可以询问用户是否离开该界面。
- 浏览器向服务器发送请求，发送请求前首先会查找缓存，比如dns缓存、http缓存。
- 然后准备ip地址和端口号，如果没有dns缓存那么会进行dns解析获取，如果是http请求的话端口号是80，https默认是443。、
- 准备好ip和端口后进入tcp等待队列，浏览器默认支持6个tcp连接，超过了就得进行等待。
- 等待后进入tcp连接，使用三次握手协议
- tcp连接后发送请求信息，请求信息包括请求行、请求头、请求体。
- 服务器收到请求后会进行响应，返回content-type如果是application/octep-stream那么浏览器的下载管理器会进行下载，如果是text/html那么会进行显示html。
- tcp断开链接，采用四次挥手，如果有keep-alive那么会保持链接，可以省去下次tcp连接时间,http1.1后默认开启了持久化链接。
- 如果返回的状态码是301和302那么会进行重定向。
- 收到html后那么就会进行渲染，首先会构建DOM树，dom树可以被js进行修改
- 进行样式计算，样式计算遵循继承和层叠计算原则
- 生成布局树，在这个阶段会遍历dom，将可见的dom添加进布局树中，如果是dispay:none是不会添加进入的
- 进行布局计算，将每个元素的几何位置添加到布局树钟
- 分层，页面中有许多复杂的效果，比如3D转换、页面的滚动、或者使用z-index做z轴的排序，为了实现这些效果，渲染引擎会专门生成对应的图层，并生成一颗图层树。生成图层得满足以下的条件： 拥有层叠上下文属性的元素会被提升为单独的一层。明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。 需要剪裁（clip）的地方也会被创建为图层，如果出现滚动条，滚动条也会被提升为单独的层。
- 图层的绘制，所谓的绘制是指将图层分绘制拆封成很多小的指令，然后在把这些很小的指令生成待绘制的列表，用于绘制的顺序。绘制列表会传递给合成线程
- 合成线程收到绘制列表时会进行删格化操作，删格化操作前会将图层划分成图块，这是因为如果将整个图层进行删格化对浏览器开销比较大，然后在将视口附近的图快生成位图，生成位图的操作称为删格化。渲染进程维护了一个删格化线程，所有的删格化都是在这个线程池完成。删格化还会进行gpu加速，被称为gpu删格化。而gpu操作是在gpu进程中运行的，生成的位图被保存在 GPU 内存中，代所有图块完成光栅化后，将结果返回给合成线程。所以这就涉及到了跨进程的处理。
- 合成显示，一旦所有的图快都完成了栅格化，合成线程就会生成一个“DrawQuad”绘制图层的指令，然后将该指令提交给浏览器进程的viz组件，然后浏览器进程会根据drawquad指令将页面内容绘制到内存中显示。


**DOM树是如何生成的**

- 渲染引擎接受到html后会交给html解析器解析成字节流，这是一个边接受html变解析的过程。
- 然后字节流会进行分词，转换成Token。Token包括Text Token和Tage Token。Tage Token又分为start tage和end tag
- 然后将分词转换成dom，构建dom树。在这个阶段会维护一个Token栈用来维护父子关系。如果是start Tag那么会入栈，将该节点添加进dom树。他的父节点即上一个栈顶元素。如果是文本Token那么不添加进栈中，直接添加进dom树。如果是endtag，那么会查看栈顶元素是否是对应的start tag。如果是从栈顶中弹出，代表当前节点解析完成。



**js为什么是单线程**

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。


**同源策略**

同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。只要端口、协议、域名不同都会出现跨域的情况。



**webkit的体系架构**
webkit的最底层是操作系统，不同浏览器可能会依赖不同的操作系统，同一个浏览器使用的 WebKit 也可能依赖不同的的操作系统。操作系统之上的就是 WebKit 赖以工作的众多第三方库，WebCore 包含了了目前被 各个浏览器所使用的 WebKit 共享部分，这些都是加载和渲染网页的基础部分，它们必不可少，包括 HTML (解释器)、CSS (解释器)、SVG、DOM、渲染树（RenderObject 树和RenderLqyer 树等)，以及 Inspector(Web Inspector和调试网页)。这些共享部分有些是基础框架，其背后支持也需要各个平台的不同实现。
JavaScriptCore 引擎是 WebKit 中默认 JavaScript 引擎，也就是说一些 WebKit 的移植使用该引擎。而且它只是默认，并不是唯一的，是可以替换的。事实上，WebKit 中对 JavaScript 引擎的调用是独立于引擎的。在 Google 的 Chormium 开源项目中，它被替换成 V8 引擎。
WebKit Ports 指的是 WebKit 中的非共享部分，对于不同浏览器使用的 WebKit 来说，移植中的这些模块由于平台差异、第三方库和需求不同等原因，往往按照自己的方式来设计与实现，这就产生了移植部分，这也是导致众多 WebKit 版本的行为并非一到的重要原因。这其中包括硬件的 加速架构，网络栈，视频解码，图片解码等。
在 WebCore 和 WebKit Ports 之上的层主要是提供嵌入式编程接口，这些接口是提供给浏览器调用（当然也可以有其他使用者）。图中有左右两个部分分别是狭义 WebKit 的接口和 WebKit2 的接口。因为接口与具体的移植有关，所以有一个与浏览器相关的绑定层。绑定层上面就是 WebKit 项目对外暴露的接口层。实际上接口层的定义也是与移植密切相关的，而不是 WebKit 有什么统一接口。