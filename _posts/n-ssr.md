**什么要进行ssr**

首先spa在启动的时候，首先要先加载js和css，待js加载完后然后开始执行，发送请求，将数据内容与资源渲染奥屏幕上。这会导致白屏时间较长。所以就出现了SSR，SSR主要是为了页面直出，节省性能，同时也可以解决SEO的问题，但是比较复杂难以维护，并且对服务器的性能损耗比较大。

reactssr的原理：ssr依赖的是虚拟dom，因为Node中是不能操作dom对象的，react的ssr只能将虚拟dom转换成虚dom输出，然后通过js对象将虚拟dom进行挂载。

react-同构的步骤
- 首先我们先利用koa渲染一段html，然后利用renderToString和renderToNodeStream渲染app应用相关的组件,渲染完成后放入root的div中，实现真正的服务端渲染
- 由于renderToString和renderToNodeStream只能处理html dom元素，不能处理逻辑，所以还需要利用webpack对客户端进行构建，引入构建后的js文件
- 对前后端的路由进行拆分，前端路由为 browRouter，后端路由 staticRouter，并分别绑定
- 这样基本完成了，但是数据并没有跟随服务端一起渲染，需要客户端发送请求响应的数据然后再进行渲染
- 解决该完问题首先对路由进行改造，在路由上添加一个loadData方法请求数据的加载，后端通过matchRoute匹配对应的路由，判断是否有loadData，然后进行加载。加载完后挂载到window上。也就是所谓的注水操作。
- 现在的问题是如果一个路由匹配到了多个界面，无法处理多级路由的数据。这个时候就得借助状态管理，比如redux，将loadData的数据保存在状态管理中。
- 最后客户端要进行判断，如果有数据那么就不需要进行加载loadData。

我同长使用 nest.js + webpack自己灵活的配置，不用next(react的ssr框架)的原因主要是因为配置的灵活性，像bigpipe和缓存这些都可以灵活配置。同时使用nest的原因是因为不是基于OOP的，他是基于DI（依赖注入）。使用依赖注入的框架还用像inversify、awalix。想用nest的话还需要使用reflet-medate(元编程)

**同构会遇到的问题**

使用vue或者react同构进行模版引擎那么会比其他模版引擎慢。所有的模版引擎就是一个大的function，最后一个render进行输出，比如koa-swig，对服务端渲染来说最关键的就是输出一个stream,像koa-swig做的好的原因是因为他比较纯粹，就是一个stream的输出，同时还做了缓存，然后在基于buffer或者big-pipe进行输出，这也是服务端渲染的基本诉求。但对于react和vue进行服务端渲染他们不想使用模版引擎，那如果使用了koa-swig,又使用了他们的自身的模版引擎，相当于两个模版引擎。这样就难以统一，向vue2这一块做的比较糟糕的原因是因为，在用render进行输出的时候它还进行了一次diff，这没有任何意义，而且他的keep-alive是基于lru的，而这后端没有，相当于缓存机制没有，字符输出也没有。而且他的template会常驻gc，导致node无法回收，node那里有那吗内存给他使用。而react相对于vue来说要好点，但也要将服务端的string和本地的组件进行调和。因为要共用redux、recoil这些状态管理，比如服务端的值是1，在前端的需要用setTimeOut改成10，那么需要采用前端的值，所有需要进行调和，这样就又浪费了一段性能。



**ssr的优化手段**
设置缓存：
 一、页面级别缓存：，如果页面并非千人千面，总是为所有用户渲染相同的内容，我们可以利用名为 micro-caching 的缓存策略，来大幅度提高应用程序处理高流量的能力，所谓的micro-caching就是当用户请求缓存它的页面，所以下一个请求的任何其他将来自缓存。这通常在 Nginx 层完成，可以在nginx的http模块中设置

2、组件级别缓存：通过对组件设置serverCacheKey的方式，如果组件serverCacheKey相同，将复用之前渲染的组件产物，不需要重新渲染。具体是类似这样的：export default {
name: 'myComponent', // 必填选项
props: ['item'],
serverCacheKey: props => props.item.id,
render (h) {
return h('div', this.item.id)
}
}
3、接口缓存：如果部分接口返回的数据是固定的， 我们可以在node后端拉取接口的时候，设置接口缓存，缓存至对象换成系统或其他轻量存储服务，当然，你也需要设置好缓存更新策略。

二：代码实现优化
1、减少组件嵌套层次，优化HTML结构：由于组件最初需要在node后端进行VDOM计算和渲染，优化组件层次结构，减少过深曾经的DOM嵌套，可以减少VDOM计算耗时。

2、减少首页渲染数据量：根据业务调整用户首屏可见的所需渲染的数据，其他数据懒加载或异步加载。

三资源加载
流式传输：把原有的直出结果以流的形式输出，让我们可以更快的响应数据到客户端，能减少首屏渲染时间，更早开始加载页面资源






**几种渲染方式的对比**

csr:不依赖服务端的数据，客户端体验较好，内存数据共享，fp最快，但是seo不友好，FMP和FCP慢
预渲染：不依赖服务端的数据，fcp比csr快，客户端体验较好，内存数据共享但fmp比较慢，seo不友好
ssr:seo友好，首屏性能高，fmp和fcp都比csr和预渲染快，但客户端数据共享成本高，模版维护成本高
同构：seo友好，首屏性能高，fmp和fcp都比预渲染快，客户端体验比较友好内存数据共享，但是node容易造成性能瓶颈

**nginx的四层和7层**

这里的层是OSI 7层网络模型，OSI 模型是从上往下的，越底层越接近硬件，越往上越接近软件，这七层模型分别是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

四层就是基于IP + 端口的负载均衡，通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；4层是指传输层的 tcp / udp

七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器七层就是基于 URL 等应用层信息的负载均衡，7层是指应用层，通常是http。

代理原理：

4层 用的是NAT技术(网络地址转换)请求进来的时候，nginx修改数据包里面的目标和源IP和端口，然后把数据包发向目标服务器，服务器处理完成后，nginx再做一次修改，返回给请求的客户端.
7层 代理：需要读取并解析http请求内容，然后根据具体内容(url,参数，cookie,请求头)然后转发到相应的服务器，转发的过程是：建立和目标机器的连接，然后转发请求，收到响应数据在转发给请求客户端

优缺点对比：
性能：
理论上4层要比7层快，因为7层代理需要解析数据包的具体内容，需要消耗额外的cpu。但nginx具体强大的网络并发处理能力， 对于一些慢连接，nginx可以先将网络请求数据缓冲完了一次性转发给上游server,从而节省网络数据缓冲时间，提供并发性能。
灵活性：
由于4层代理用的是NAT，所以nginx不知道请求的具体内容，所以nginx啥也干不了。 用7层代理，可以根据请求内容(url,参数，cookie,请求头)做很多事情，
现在机器cpu性能都很好，4层代理并没有明显的性能优势，而7层代理在业务层面优势明显，所以都选择7层代理

**SPA和MPA**

spa所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS文件，一旦页面加载完成，SPA不会进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML，默认Hash模式是采用锚点实现路由以及元素组件的显示与隐藏实现交互，简单来说SPA应用只有一个页面，通常多页面应用会有多个页面不断跳转，而单页面应用始终在一个页面中，，默认Hash模式是通过锚点实现路由以及控制组件的显示与隐藏来实现类似于页面跳转的交互。

优点
良好的交互体验，页面首次加载完成后内容的改变不需要重新加载整个页面，具有更快的响应速度，具有桌面应用的即时性、网站的可移植性和可访问性。
良好的前后端工作分离模式，单页应用可以和RESTful架构一起使用，通过RESTAPI提供接口数据，有助于分离客户端和服务器端工作与API通用化。
减轻服务端压力，服务端不需要处理页面模板的逻辑与拼接，除首次加载页面外只需要提供数据信息即可，把计算尽量放在客户端，单页应用能提高单位服务器的负载量。
可维护性高，通常采用组件化与模块化开发，代码复用程度高，相对来说可维护性高。
缺点
不利于SEO，由于是采用前端渲染的方式，搜索引擎不会去解析Js从而只能够抓取首页未渲染的模板，如果需要单页面应用有更好的SEO，那么通常需要使用SSR服务端渲染，搜索引擎爬虫抓取工具可以直接查看完全渲染的页面，但是由于是服务端进行渲染，那么会对服务器造成一定压力，SSR服务端渲染属CPU密集型，当然如果只是需要SEO少数几个页面，可以采用预渲染的方式。
首次加载速度慢，SPA单页应用通常首次加载页面时就会将相应的HTML、JavaScript、CSS文件全部加载，通常可以通过采取缓存措施以及懒加载即按需加载组件的方式来优化。

MPA：
优点：项目架构起源很早，上手容易。对于轻量级项目开发快，可以快速的通过 html 语法描述出页面。兼容性强，在 web 开发的沉淀下 html 文件在市面所有浏览器的兼容都是很好的不会出现特别大的编译差异。
缺点：由于 html 以物理文件为核心，在一个大规模应用中会产生大量的 html 文件，导致占用存储空间大。每次跳页都需要加载新的 html 文件，虽然本地会有缓存，但是如果页面量特别多的项目用户在第一次访问时每次跳页都相当于重新加载网页。由于 html 网页开发并没有严格的工程化规范，并且大量都依赖于 JQuery 来开发所以复杂页面的代码再后期的维护和功能扩展会由于代码量大以及结构混乱导致难以良性的扩展。