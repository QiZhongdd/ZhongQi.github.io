**什么是serverless**

serverless主要是为了服务端免运维，主要解决的就是将小服的工作彻底透明化；研发同学只关心业务逻辑，不用关心部署运维和线上的各种问题。serverless架构是fass+bass。所谓的FaaS就是函数即服务，它可以让我们随时随地创建、使用、销毁一个函数。在 FaaS 中，函数需要实例化，然后被触发器 Trigger 或者被其他的函数调用。FaaS 的 Runtime 是预先设置好的，Runtime 里面加载的函数和资源都是云服务商提供的，我们可以使用但无法控制，用完就会被云服务商销毁ntrol 函数。在 HTTP 的数据请求量大的时候，FaaS 函数会自动扩容多实例同时运行；在 HTTP 的数据请求量小时，又会自动缩容；当没有 HTTP 数据请求时，还会缩容到 0 实例，节省开支。BaaS 其实是一个集合，是指具备高可用性和弹性，而且免运维的后端服务，主要用来提供一些持久化的服务。可以把fass和bass理解成mvc中的control和model层。

小服的工作职责：
- 无需用户关心服务端的事情（容错、容灾、安全验证、自动扩缩容、日志调试等等)。
- 按使用量（调用次数、时长等）付费，低费用和高性能并行，大多数场景下节省开支。
- 快速迭代 & 试错能力（多版本控制，灰度，CI&CD 等等）。


**FaaS 的内部运行机制**

- 纯 FaaS 应用调用链路由函数触发器、函数服务和函数代码三部分组成，它们分别替代了传统服务端运维的负载均衡 & 反向代理，服务器 & 应用运行环境，应用代码部署。
- 对比传统应用托管 PaaS 平台，FaaS 应用最大的不同就是，FaaS 应用可以缩容到 0，在事件到来时极速启动，Node.js 的函数甚至可以做到 100ms 启动并执行。FaaS 中的冷启动是指从调用函数开始到函数实例准备完成的整个过程包括（资源调度、下载代码、启动容器和runtime），云服务商还会不停地优化冷启动，毕竟启动速度越快对资源的利用率就越高，例如冷启动过程中耗时比较长的是下载函数代码。请求第一次访问时，云服务商就可以利用构建好的缓存镜像，直接跳过冷启动的下载函数代码步骤，从镜像启动容器，这个也叫预热冷启动。所以如果我们有些业务场景对响应时间比较敏感，我们就可以通过预热冷启动或预留实例策略，加速或绕过冷启动时间。
- FaaS 在设计上牺牲了用户的可控性和应用场景，来简化代码模型，并且通过分层结构进一步提升资源的利用率，这也是为什么 FaaS 冷启动时间能这么短的主要原因。FaaS 实例执行时至少是 3 层结构：容器、运行时 Runtime、具体函数代码。容器可以理解为操作系统 OS，让你的代码和 Runtime 可以在里面运行。运行时 Runtime，就是函数执行时的上下文 context，包括代码运行的语言和版本。通过分层，我们可以做到资源统筹优化，这样就能让你的代码快速低成本地被执行。

**fass的进程模型**

用完即毁型：函数实例准备好后，执行完函数就直接结束。这是 FaaS 最纯正的用法。常驻进程型：函数实例准备好后，执行完函数不结束，而是返回继续等待下一次函数被调用。这里需要注意，即使 FaaS 是常驻进程型，如果一段时间没有事件触发，函数实例还是会被云服务商销毁

**fass如何动态扩容**
扩容有两种一种是横向扩容，一种是纵向扩容。考虑到成本，通常选择横向扩容。fass节点属于网络节点中的stateless节点，不需要保存持久化数据，可以任意的根据流量扩容。如果需要保存数据那么需要保存在bass.

**bass**

bass是一系列服务的集合，通常提供了数据的持久化、redis、定时任务等。类似于微无服务吧，将复杂的大型应用拆解成职责单一的小功能模块，各模块之间数据模型相互独立，模块采用 API 接口暴露自己对外提供的服务，然后再通过这些 API 接口组合成大型应用。如果提供持久化的节点涉及到了扩容那么需要对数据库解耦，。所谓的数据库节藕就是通过额外进程让数据库与副本直接通过消息队列进行同步，例如 MySQL，写的操作都会产生 binary log，通过额外的进程将 binary log 变更同步到消息队列，并监听消息队列将 binary log 更新在本地执行，修改 MySQL，比较著名的解决方案就是kafka（分布式日志系统）。微服务通过数据库解耦，将后端应用变成 Stateless 的了，但对后端应用本身而言，数据库还是 Stateful 的。








serverless主要是为了服务端免运维，主要解决的就是将小服的工作彻底透明化；研发同学只关心业务逻辑，不用关心部署运维和线上的各种问题。serverless架构师fass+bass。所谓的FaaS就是函数即服务，它可以让我们随时随地创建、使用、销毁一个函数。在 FaaS 中，函数需要实例化，然后被触发器 Trigger 或者被其他的函数调用。纯 FaaS 应用调用链路由函数触发器、函数服务和函数代码三部分组成，它们分别替代了传统服务端运维的负载均衡 & 反向代理，服务器 & 应用运行环境，应用代码部署。FaaS 应用可以缩容到 0，在事件到来时极速启动，Node.js 的函数甚至可以做到 100ms 启动并执行。FaaS 中的冷启动是指从调用函数开始到函数实例准备完成的整个过程包括（资源调度、下载代码、启动容器和runtime），云服务商还会不停地优化冷启动，毕竟启动速度越快对资源的利用率就越高，例如冷启动过程中耗时比较长的是下载函数代码。请求第一次访问时，云服务商就可以利用构建好的缓存镜像，直接跳过冷启动的下载函数代码步骤，从镜像启动容器，这个也叫预热冷启动。所以如果我们有些业务场景对响应时间比较敏感，我们就可以通过预热冷启动或预留实例策略，加速或绕过冷启动时间。并且FaaS通过分层结构进一步提升资源的利用率，这也是为什么 FaaS 冷启动时间能这么短的主要原因。FaaS 实例执行时至少是 3 层结构：容器、运行时 Runtime、具体函数代码。容器可以理解为操作系统 OS，让你的代码和 Runtime 可以在里面运行。运行时 Runtime，就是函数执行时的上下文 context，包括代码运行的语言和版本。通过分层，我们可以做到资源统筹优化，这样就能让你的代码快速低成本地被执行。fass的进程模型有用完即毁型：函数实例准备好后，执行完函数就直接结束。常驻进程型：函数实例准备好后，执行完函数不结束，而是返回继续等待下一次函数被调用，如果一段时间没有事件触发，函数实例还是会被云服务商销毁，fass可以动态的扩容，fass属于stateless节点，不需要保存持久化数据，可以任意的根据流量扩容。如果需要对数据进行持久化那么就需要用到bass，bass是一系列服务的集合，通常提供了数据的持久化、redis、定时任务等。类似于微无服务吧，将复杂的大型应用拆解成职责单一的小功能模块，各模块之间数据模型相互独立，模块采用 API 接口暴露自己对外提供的服务，然后再通过这些 API 接口组合成大型应用。如果提供持久化的节点涉及到了扩容那么需要对数据库解耦，。所谓的数据库节藕就是通过额外进程让数据库与副本直接通过消息队列进行同步，例如 MySQL，写的操作都会产生 binary log，通过额外的进程将 binary log 变更同步到消息队列，并监听消息队列将 binary log 更新在本地执行，修改 MySQL，比较著名的解决方案就是kafka（分布式日志系统）。微服务通过数据库解耦，将后端应用变成 Stateless 的了，但对后端应用本身而言，数据库还是 Stateful 的。


