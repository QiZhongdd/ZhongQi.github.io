
性能优化的相关指标：FP首次绘制、FCP首次有内容的绘制、FMP首次有意义的绘制、TTFB首字节加载的时间、TTI可交互的时间，交互响应的时间不能大于100会有延迟感、LCP记录视窗内最大内容的绘制时间，会随着渲染时间变化而变化，在首次交互的时候会停止记录。FID首次交互延迟记录，在FCP到TTI用户交互的响应时间的延迟。TBT（Total Blocking Time）阻塞总时间，记录在 FCP 到 TTI 之间所有⻓任务的阻塞时间总和。CLS累计位移偏移，CLS 代表了⻚⾯的稳定，CLS 值⼀⼤的话会让⽤户觉得⻚⾯体验做的很差。

**为什么使用LCP计算，不是FMP**
FMP（First Meaningful Paint：首次有意义的渲染帧。FMP 是指从页面加载开始，到大部分或者主要内容已经在首屏上渲染的时间点。FMP 指标的计算方法为：新增的布局对象发生变化最大的下一个时刻。也存在一些场景不适用上述的情况：、如果页面为长页面，那么会存在不可见布局对象增加的个数比首屏内可见对象增加个数更多的情况，此时 FMP 就是不准确的、有加载web字体的情况，文字会使用降级字体进行布局，但是默认在 loadstart 开始的3s内，不进行绘制，这样也会影响FMP的计算。生产环境中，FMP 对页面细微的变化太过敏感，容易导致结果不一致。该指标的定义比较依赖于浏览器具体的实现细节，不具有可参考的标准性。LCP 指的是在视窗内，最大的内容元素被渲染的时间，这些元素包括img、<img>、<svg> 里面的 <image>、<video>、通过 url() 函数加载背景图片的元素、包含 text node 的块级元素或者 inline text 的子元素。如何确定元素的大小？主要是以下 4 个规则：在 viewport 内可见元素的大小，如果是超出可视区域或者被裁减、遮挡等，都不算入该元素大小。对于图片元素来说，大小是取图片实际大小和原始大小的较小值，即Min(实际大小，原始大小)。对于文字元素，只取能够覆盖文字的最小矩形面积。对所有元素，margin、padding、border 等都不算。LCP 是一个十分重要并且以用户感受为中心的指标；它反映了感知层面上页面的加载速度；它标记了页面主要内容中最大内容元素加载完成的时间点；LCP 较短的页面能够让用户更快感觉到页面是可用的。


**优化**

 在做性能监控的时候不能盲目的进行监控，首先要用肉眼看下什么感觉，接下来要接入很多工具，知道到底是lcp慢、fcp慢还是fid慢，然后做性能的sdk，将相关的性能指标上传到日志服务器，日志服务器要每天晚上做数据的清洗，然后观看性能指标相对于之前是否有提升。对spa关键的指标是fcp，fmp已经被废弃了。fcp和fp决定了页面什么时候渲染，这两个指标有明显改善的话那么对用户的感观比较好的，可见即可操作吗。可操作也有几个关键的指标，第一个是fid，用户第一个什么时候可执行，lcp（视口内可见的最大内容元素的渲染时间。元素包括img、video、div及其他块级元素。）还有tbt可交互的时间的时间（衡量从FCP到TTI之间主线程被阻塞时长的总和。）和cls。比如最大内容绘制是不是特别大，造成用户的感观特别不好，cls需要较小。还有就是long task，如果long task不关心的话就不知道造成了多少重绘和重排了。至于dns时间、tcp握手的时间、白屏时间（navigationstart、requsetRespondStart）都可以用performance.timing获取到。
怎么衡量性能到底好不好呢：像lcp、fcp、cls这些指标都能在谷歌的官方的web-wital都能看到他的推荐之，比如lcp2.5s内是比较好的，如果高于2.5s那么意味着需要优化，这是一个经验值。还有就是我们通过sdk可以查看pv或者uv的秒开率，就是1s内快速打开，比如1000个uv和pv有80%或者70%是合格，这是经验值，这是我们自己的指标。
webview的打开时间纯前端是无法统计，需要其他端的同学配合吧


**请求阶段 fcp**
- 利用preconnect和dns-prefect进行预链接和预解析。请求的很大一部分时间都花在了链接上，特别是进行安全链接的情况下，需要dns解析、证书的验证、服务器间的重定向等。使用预链接和dns预解析能够降低用户的感知时间，并且这不会对服务端造成什么影响
- 避免使用重定向，如果资源地址发生了变化，那么直接采用变化的地址
- 对静态资源配置http缓存策略，如果是js的话可以保持在localstorage和indexdb里面。
- 降低传输载核的大小，对于js和css需要压缩，去除无效的代码。对于图片可以采用webp，有些浏览器不支持webp，需要降级，一般采用探测图片的宽高，在图片onload的时候查看图片的宽高，如果不符合预期，则加载jpeg或者png，配置gzip的传输。
- 减少请求数量，一个域名下tcp的链接数只能同时发起6个，多了6个需要排队等待。对于图标可以使用雪碧图或者font-icon，js或者css能合并就合并。
- 使用http2就不会有tcp的链接限制了
- 降低服务端的响应时间，提高服务端的性能，提高cpu和内存。如果使用了服务端渲染，例如react可以使用renderToNodeStream提高传输效率。

**解析阶段**
- 对于关键的js可以考虑使用内链，这样就不需要进行网络加载了。所谓的关键js是影响dom的解析和渲染的。对于非关键的js可以存放至cdn或者使用async、defer进行异步加载。
- css也是，核心的css可以直接内链，非核心的css可以使用preload预加载
- 去除无效的css，无效的css可以直接通过source面板中的coverage查看。
- 避免过多的dom,过多的dom会延长解析和渲染的时间，同时如果用户交互的话会造成延迟，因为他要去查找和计算。平时写代码需要注意，一些交互才会产生的dom那么交互时在产生。
- font字体，有些浏览器的文本会在网络字体加载完成后才会显示，可以配置font-display:wrap在加载之前使用系统字体。也可以使用preload预加载。
- 降低关键资源的请求链时间，关键资源就是所谓的影响页面渲染的js和css。提升关键资源的请求顺序，对于一些js可以延迟加载，比如组件的懒加载，react组件可以使用quicklink，他会在根据线程是否空闲或者是否在视窗范围进行预加载。

**其他**

- css动画绘制的开始的时机可以使用requestAnimationFrame进行绘制
- 避免引起重绘和重排，使用gpu硬件加速、分层。
- 对dom的操作要进行读写分离。dom的读写也会引起重绘和重拍。





# 性能监控之获取网页跳转阶段的相关事件

- 根据 performance.time 获取到加载网页的各个阶段的时间，比如
  白屏时间可以用 reponsetstar-navigationStart 获取
     //页面onload时间
  loadTime: n.loadEventEnd - n.navigationStart || 0,
  fetchTime: responseEnd - n.fetchStart,


在集合完数据后，使用 requestIdlecallback 进行数组的发送

error 监控：
全局 error 监听：window.onerror
promise:监听 unhandlerRejection
网络：监听 error，如果 event.target 不等于 window 就是 error;

错误数据上报使用 navigator.sendBeacon，navigator.sendBeacon 会在页面关闭的时候上传数据，并且不会延迟页面跳转的时间。也可以用为什么用 1x1 像素 gif 图？去上传。没有跨域问题；发 GET 请求之后不需要获取数据、服务器也不需要发送数据；不会携带当前域名 cookie !不会阻塞页面加载、影响用户体验，只需要 new Image 对象；相比 BMP/PNG 体积最小，可以节约 41%/35% 的网络资源大小。
性能监控之获取 fp lcp fcp cls ttb(long-task)。

利用 performance.oberver 获取到性能条目，比如 paint 包括 fp fcp，first input delay,lastContentpaint:lcp layout-shift 累计得到页面的cls,resource 获取得到相关资源的加载时间，比如图片、js 等。ttb 是指长耗时任务，从 resource 中获取到的资源好使大于 50ms 的就是长时的任务

本地存储

可以使用 window.navigator.storage.estimate 获取本地存储的状态，该接口只能在 https 中使用

UV（Unique visitor）
是指通过互联网访问、浏览这个网页的自然人。访问您网站的一台电脑客户端为一个访客。00:00-24:00 内相同的客户端只被计算一次。一天内同个访客多次访问仅计算一个 UV。
在用户访问网站时，可以生成一个随机字符串+时间日期，保存在本地。在网页发生请求时（如果超过当天 24 小时，则重新生成），把这些参数传到后端，后端利用这些信息生成 UV 统计报告。

PV（Page View）
即页面浏览量或点击量，用户每 1 次对网站中的每个网页访问均被记录 1 个 PV。用户对同一页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。

页面停留时间
传统网站
用户在进入 A 页面时，通过后台请求把用户进入页面的时间捎上。过了 10 分钟，用户进入 B 页面，这时后台可以通过接口捎带的参数可以判断出用户在 A 页面停留了 10 分钟。
SPA
可以利用 router 来获取用户停留时间，拿 Vue 举例，通过 router.beforeEach destroyed 这两个钩子函数来获取用户停留该路由组件的时间。

浏览深度
通过 document.documentElement.scrollTop 属性以及屏幕高度，可以判断用户是否浏览完网站内容。

页面跳转来源
通过 document.referrer 属性，可以知道用户是从哪个网站跳转而来。

小结
通过分析用户数据，我们可以了解到用户的浏览习惯、爱好等等信息，想想真是恐怖，毫无隐私可言。


# sourcemap的字段介绍

```

{
   version : 3, // sourcemap的版本
   file: "add.js", // 转换后的文件
   sourceRoot : "", // 转换前的文件的目录，如果与转换前的目录在同一个位置那么为空
   sources: ["add.ts"], // 转换前的文件，该项是一个数组，表示可能存在多个文件合并
   names: [], // 转换前所有的变量名，多用与minifer场景
   sourcesContent: [ // 原始文件内容
    "const add = (x:number,y:number) => {\n  return x+y;\n}"
  ]
  mappings: "AAAA,IAAM,GAAG,GAAG,UAAC,CAAQ,EAAC,CAAQ;IAC5B,OAAO,CAAC,GAAC,CAAC,CAAC;AACb,CAAC,CAAA",
}

```

**mapping**

mapping主要记录了行列与源文件的映射信息。
- “;”分割代表一行，每一行有多个segment，代表该行所在列的映射信息
- 每一个segment又包含了多个file,表示列的不同的映射信息。
- - 第一位转换后代码所在的列号，如果是当前行的segmentn是一个，那么是个绝对值，其余的是相对于上一个的相对值
- - 第二个表示属于souce属性的哪一个文件，相对于前一个segment的位置，下一行的segment中仍是相对于上一行的最后一个
- - 表示这个属于转换前代码的第几行，也是个相对值，下一行的第一个相对于上一行最后一个
- - 表示这个属于转换前代码的第几列，也是相对值
- - 表示这个位置属于names属性中的哪一个变量，相对位置

**错误定位：**

将 soucemap 上传到监控平台，可以主动上传，也远程编译利用 rsync 进行传输、还可以通过手写 webpack 插件在编译的时候进行上传

先定位编译后的错误地址获取到报错的行数和列数
使用 souce-map 中的 originalPositionFor查找对应的源码位置，然后在用codeframe从sourcecontent中获取到对应的代码片段。

# css动画为什么高效

生成任意一帧的方式，有重排、重绘和合成三种方式。通常渲染路径越长，生成图像花费的时间就越多。所以这三种方式的耗时重排>重绘>合成，并且重排一定会导致重绘、合成。重绘会导致合成。需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。
Web 应用的时候，可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。这时你可以使用will-change， 来告诉渲染引擎你会对该元素做一些特效变换，使用will-change的元素会单独变成一层，那么在做css动画时只要去操作对应图层就可以了。



**大规模计算**

**JavaScript 实现线程锁**

ECMAScript 2018 中增长了 SharedArrayBuffer 和 Atomics ，利用它们能够实现锁（Lock），即页面主线程和 Web Worker 线程间的锁。SharedArrayBuffer（如下简称为SAB） 是一个能够主线程和 Web Worker 线程间共享数据的对象，即同一个 SAB 能够被多个线程读写。 避免了多个线程间为了传递数据而进行数据拷贝，但同时缺引入了经典的数据访问「冲突」,这时候就须要原子操做,Atomics 能够实现对于 SAB 原子访问。

GPU.js是一个针对Web和Node.js构建的JavaScript加速库，，它使你可以将复杂且耗时的计算移交给GPU而不是CPU，以实现更快的计算和操作。当你要执行复杂的计算时，实质上是将这种负担转移给系统的GPU而不是CPU，从而增加了处理速度和时间。。以下是使用GPU的一些最值得注意的好处。GPU可用于执行大规模并行GPU计算。这是需要异步完成的计算类型当系统中没有GPU时，它会优雅地退回到JavaScript,GPU当前在浏览器和Node.js上运行，非常适合通过大量计算来加速网站
GPU.js是在考虑JavaScript的情况下构建的，因此这些功能均使用合法的JavaScript语法。
引出wasm

**如何进行性能分析** 

如果一个页面pendding时间太长   你怎么分析并解决这个问题

- 利用performance面板进行录制，如果是录制交互时的操作，可以暂停，录制前可以进行配置，比如网络环境、cpu核数
- 录制完后有报告主要有三大块，概览面板、性能指标面板和详情面板。
- 概览面板有将几个关键指标，诸如页面帧速 (FPS)、CPU 资源消耗、网络请求流量、V8 内存使用量 (堆内存) 等，按照时间顺序做成图表的形式展现出来，这就是概览面板，，如果 FPS 图表上出现了红色块，那么就表示红色块附近渲染出一帧所需时间过久，帧的渲染时间过久，就有可能导致页面卡顿。如果 CPU 图形占用面积太大，表示 CPU 使用率就越高，那么就有可能因为某个 JavaScript 占用太多的主线程时间，从而影响其他任务的执行。如果 V8 的内存使用量一直在增加，就有可能是某种原因导致了内存泄漏。当然还有想fp、LCP、DOMContentLoaded、Onload 等事件产生的时间点。
- 概览面板来定位到可能存在问题的时间节点,需要利用性能面板查看具体的原因，在性能面板中，记录了非常多的性能指标项，比如 Main 指标记录渲染主线程的任务执行过程，Compositor 指标记录了合成线程的任务执行过程，GPU 指标记录了 GPU 进程主线程的任务执行过程。有了这些详细的性能数据，就可以帮助我们轻松地定位到页面的性能问题。
- 通过性能面板的分析，我们知道了性能面板记录了多种指标的数据信息，并且以图形的形式展现在性能面板上。如果想要查看这些记录的详细信息，就需要引入详情面板了。
# 利用网络看板做性能分析

在下载信息中有DOMContentLoad和Load.
- DOMContentLoad表示DOM已经解析完毕，说明css、js、html已经加载完毕
- Load表明已经加载完所有的信息（包括图像、音频）

**Queuing** 

Queuing表示请求排队的时间，排队有以下几种情况

- TCP排队，一个域名只能同时6个TCP链接，超过后得等待
- 页面请求资源是有优先级的，比如css、js、html的优先级比较高，而音频、图片、视频的优先级较低
- 网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。

**Stalled**

表示停滞，有一些原因可能导致请求停滞

**Waiting**

waiting也表示第一字节时间(TTFB)，TTFB越短，表示响应时间越快

**ContentLoad**

第一字节时间到接收完所有字节的时间


**waiting时间过长**

- 服务器生成页面数据的时间过久。解决方法是合理使用缓存，提高服务的响应速度
- 网络的原因，可以使用cdn访问静态资源
- 发送请求头时带上了多余的用户信息。比如带了一些cookie,服务器收到这些cookie后会进行处理，加大了服务器的压力。

**Initial connection/SSL**

表示TCP链接的时间，如果用来Https,还表示TSL/SSL握手的时间

**ContentLoad过长**

有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。




