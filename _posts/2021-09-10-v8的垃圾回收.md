---
layout: post
title: v8的垃圾回收
subtitle: v8的垃圾回收
date: 2021-07-29
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - v8
---

# 垃圾回收算法的步骤

- 通过遍历 GCROOT，标记堆空间中的活动对象和非活动对象，活动对象保留，非活动对象清理
- 整理内存空间，清理完非活动对象会存在不连续的内存空间，不连续的内存空间称为内存碎片，当内存碎片太多的时候如果需要添加一份大的连续内存的时候就会造成内存空间不足，所以需要内存整理。

# 新生代和老生代

V8 的垃圾回收策略主要基于分代式垃圾回收机制。V8 有两个垃圾回收器主垃圾回收器（Major GC）和副垃圾回收器（Minor GC）。分别对老生代和新生代进行回收。V8 内层分为新生代和老生代。

- 新生代，存活时间较短的变量
- 老生代，存活时间较长的对象，比如 window、DOM、WEB API,在一定条件下新生代对象也能转变成老生代

# Scavenge 算法

新生代的对象主要通过 Scaverage 算法进行垃圾回收，将空间一分为二，分别为正在使用的 from 空间和闲置的空间 to。分配时会先分配到 from,等到 from 快要满的时候它会将存活的对象推给 to，未存活的被释放，然后 from 和 to 互换，这时候 from 变成了 to,to 变成了 from。等过了一段时间快要 from 快要满的时候，再次进行垃圾回收。如果对象进行了两次垃圾回收还存活，那么该对象会晋升为老生代，或者 to 的空间使用超过 25%了，那么它会将此时 to 空间的对象直接晋升到老生代，在老生代中进行回收。Scavenge 算法的缺点是只能占用一半的堆内存，典型的空间换取时间。由于新生代存活时间较短，所以也比较适合该方法。如果新生代爆栈了，那么就不进行 GC
![Image text](/img/WechatIMG12.png)

上图解释：

- 首先将内存变量 a 和 b 分配给 from，
- 等到 from 空间快满的时候，会将 a 推到 to 空间，b 会释放掉，因为 a 被引用了，b 没有。
- a 推到 to 后，会将 to 和 from 互换位置，to 编程 from，from 变成 to。
- 等到 from 空间快要满的时候回再次进行垃圾回收，如果 a 进行了两次垃圾回收，a 还存在，那么 a 会晋升为老生代。

# Mark-Sweep & Mark-compact

Mark-Sweep 和 Mark-compact 是老生代进行垃圾回收的算法，Mark-Sweep 首先将需要进行垃圾回收的变量进行标记，然后清除，但是标记清除会出现内存不联系的情况，这是对内存的一种浪费。这时候就使用 Mark-compact 方法，它首先将不需要清除的对象统一推到右边，然后前面的内存空间清除掉。

![Image text](/img/WechatIMG13.png)

# v8 是如何优化垃圾回收的执行效率的

js 执行和垃圾回收都是执行在主线程中的，所以一旦执行垃圾回收 js 执行就得暂停，如果垃圾回收时间较长，就会造成 js 执行卡顿，也就是所谓的全停顿。v8 为了解决这个问题，副垃圾回收器采用了并行回收，主垃圾回收采用了并行回收、增量回收、并发回收相结合的回收策略。

**并行回收**

并行回收是指在进行垃圾回收的时候，同时开启多个协助线程进行回收，副垃圾回收器采取的就是并行回收，

![Image text](/img/00537bdadac433a57c77c56c5cc33c1f.webp)

**增量回收**

并行回收一种全停顿的方式，同样也可能造成 js 执行卡顿。像 widnow、global 这些在老生代回收的比较大的对象，回收时间会比较长，所以在老生代中引入了增量回收。所谓的增量回收是指将回收工作拆分成多个小块，每次执行一小部分，穿插在主线程执行不同的任务之间。

![Image text](/img/be18e6dc6c93e761a37d50aed48f246f.webp)

采用增量回收非常重要的两个条件就是

- 垃圾回收能随时停止和启动
- 在暂停期间被标记的对象如果被 js 修改了能够准确识别。


所以垃圾回收进行标记采用的是**三色标记法**，所谓的三色标记法是指通过 gcroot 遍历节点，如果能查找到的节点会被标记成黑色，没有查找到的会标记成白色，在进行一次完全的遍历完成后会被回收。如果在此次遍历查找子节点没有遍历完或者正在进行那么会被标记成灰色，下一次遍历会从这个节点开始遍历。如果 js 在执行的时候将前面标记成白色的节点修改成被 gcroot 引用，那么会将该节点标记成灰色。**黑色节点是不能指向白色节点的，这也就是所谓的写屏障机制**

**并发回收**

虽然不管是并行回收和增量回收都提高了垃圾回收的效率，但两者都会阻塞 js 的执行。所以后来引入了并发回收，所谓的并发回收是指在后台开启辅助线程进行回收，**与并行回收不同的是并发回收主线程不会进行回收**。并发回收是三者中效率最高的，但也是最难的一种。这主意是有以下两个原因：

- 在 js 执行的时候可能修改堆中的对象，就会造成辅助线程之前做的工作白费了
- 主线程和辅助现场可能同时修改一个对象，这就需要额外的读写锁的功能。

**这三种技术在实际使用中，并不是单独的存在，通常会将其融合在一起使用，V8 的主垃圾回收器就融合了这三种机制，来实现垃圾回收**

![Image text](/img/7b8b901cb2eb575bb8907e1ad7dc1842.webp)

- 首先主垃圾回收器采用并发进行标记，在主线成执行的 js 的时候就标记玩了。
- 等标记完成后采用并行的方式进行清理。
- 同时主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种 JavaScript 任务之间执行。

