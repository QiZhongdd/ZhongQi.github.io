---
layout: post
title: v8延迟解析，v8是如何实现闭包的
subtitle: v8延迟解析，v8是如何实现闭包的
date: 2021-07-29
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - v8
---

# 惰性分析

v8 在执行的时候会采用先编译后执行，编译过程是指将 js 代码编译出字节码的阶段。如果 js 的代码量太大的话，那么编译的时间就会较长，同时一次性解析万所有代码也会造成 cpu 内存的浪费。为了解决这两个问题，v8 采用了惰性分析。所谓的惰性分析是指在编译的时候只编译顶端代码，不编译函数，只是将函数转换成一个函数对象保存在内存中，等到函数调用的时候再对函数进行编译。

**解析过程**

- 遇到 foo 函数，转换成 foo 函数对象保存在内存中
- 对变量 a,c 进行编译转换 ast->字节码-》解释执行
- 调用 foo 函数，在内存中找到 foo 函数，然后进行编译

```


function foo(a,b) {
    var d = 100
    var f = 10
    return d + f + a + b;
}
var a = 1
var c = 4
foo(1, 5)

```

# 惰性分析遇到闭包

闭包的内部函数会引用外部函数的变量.当外部函数执行完毕后外部
函数的执行上下文会出栈，按照通用的做法引用的变量也会被销毁。但变量却没有被销毁，v8 采用了惰性分析+预解析的策略。如果只采用惰性分析的策略，当执行外部函数的时候，内部函数还没编译，但 v8 需要知道内部函数有没引用外部函数的变量，所以引用了预解析器

**预解析器**

当 v8 在编译顶端代码的时候，遇到函数会让预解析器先进行快速的预解析，然后才转变成函数对象。预解析的目的有两个

- 检查函数是否有错误
- 检查函数是否有引用外部的变量，如果有那么会将外部的变量复制到内存中

# 其他

调用下方两个 foo 函数,变量 a 是保存在栈中还是堆中

- 第一个函数 a 的变量会保存在栈中
- 第二个函数当执行的时候 a 首先会保存在栈中，同时对 inner 进行预解析，对 a 进行拷贝，保存在堆中，当 foo 函数执行完毕后，foo 的执行上下文出栈，同时销毁栈中的变量 a。

```

function foo() {
   var a = 0
}

```

```

function foo() {
    var a = 0
    return function inner() {
        return a++
    }
}

```
