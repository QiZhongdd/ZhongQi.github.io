**GPU而不是CPU区别**
首先CPU和GPU都包含了DRAM、Control、ALU、Cahce，但两者的设计结构不一样，CPU包含了一大块的Control和Cache,Alu数量较少。大的缓存也可以降低延时。保存很多的数据放在缓存里面，当访问数据如果缓存里面存在，那么就可以直接从缓存里面获取。复杂的逻辑控制单元（Control）。当程序含有多个分支的时候，它通过提供分支预测的能力来降低延时。CPU 擅长各种复杂的逻辑运算，但不擅长数学运行。而GPU是基于大的吞吐量设计，有较多的alu和线程，但是缓存较少， 缓存的目的不是保存后面需要访问的数据的,而是为线程服务的，所以GPU擅长的是大规模并行计算。而栅格化是要处理多个图块的，并且做的事情都是一样的，比较适合采用GPU的并行计算。


**webworker**

webworker的作用是为了javascript创建多线程环境，运行主线程建立一个worker线程，将一些任务交给后者运行。webworker一旦使用，就不会被主线程的任务所打断，这也造成了webworker比较耗费性能，所以用完了就得关闭。
webworker的限制主要有以下内容：分配给线程的脚步文件必须与主线程同源。不能操作dom对象，也无法操作window、parent这些对象。Worker但是可以操作location、navigator对象。
worker和主线程不在同一个上下文环境，那么他们不能直接通信，必须通过消息完成。
worker线程不能执行alert和confirm方法，但可以发送ajax请求。
Worker 线程无法读取本地文件，它所加载的脚本必须来自网络，用importScripts()加载脚本。
webworker传输的内容可以是文本、对象也可以是二进制数据，这种通信是拷贝的关系，即修改了数据也不会影响到主线程。

**service worker**
serviceworkw主要用于离线缓存，使用的使用sw首先会进行注册、解析执行、激活、然后监听对应的fetch请求，对相关的请求进行拦截。serviceworker更新的时候会在注册的后面多了一个waiting阶段，在waitng阶段判断是否有skipWaiting，如果没有的话要关闭终端才能更新，有的话可以直接更新。一般开发的时候都会在install阶段声明skipwaiting。更新sw主要有两种方式，跟下sw的url，通常会在url添加hash值，第二种是更新sw里面的内容。我们可以使用workbox，workbox会自动帮我们跟新sw的hash和内容。





**为什么需要模块化Module**

js 是函数级的作用域，如果多个函数需要共享变量，那么会将变量提到全局作用域中，但这会造成变量全局污染和依赖混乱的问题，所以就需要模块化来解决上述的问题
主要的模块有以下几种。
- commonjs 是node的模块依赖规范，使用export或者module.exports导出模块，export的本质是module.export，exports倒出一个对象，假如想导出一个变量或者函数可以使用module.exports中。commonjs可以运行时动态加载，首次加载对应的模块时首会缓存在内部的一个大的module中，然后再执行。执行的顺序是父子父，下次加载的时候直接从缓存中获取，不会执行。这种方式解决了循环引用的问题。
- esmodule通过import导入模块，export导出模块。只能在文件的顶端进行导入，并且导入的变量是一个常量。不能动态导入。所以esmodule的规范是高度稳定的，three-shaking的原理也是基于esmodule的这个原理。esmodule的导入的模块是提前加载并执行的，优先执行子模块，然后在执行父模块。esm的实现主要有三个步骤，首先确定模块从哪里下载，然后从url中提取或者从文件系统中提取，最后解析想对应的模块记录，解析模块记录会采用深度优先后序遍历，找到最底层的export，将export的连接到内存中，然后向上查找到对应的import,也将import链接到对应的内存，这也解决了循环引用的问题
- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行. CMD 推崇依赖就近，AMD 推崇依赖前置



**对jsbridge的了解**

就是JavaScript(H5)与Native通信的桥梁，通过JSBridge与Native通信，赋予了JavaScript操作Native的能力，同时也给了Native调用JavaScript的能力。
JSBridge与Native间通信原理

在H5中JavaScript调用Native的方式主要用两种

1.注入API，注入Native对象或方法到JavaScript的window对象中(可以类比于RPC调用)。

2.拦截URL Schema，客户端拦截WebView的请求并做相应的操作(可以类比于JSONP)。


**实现一个脚手架cli**

- 使用 commander 设置运行命令以及启动脚手架
- 使用 inquirer.js 设置交互语句，询问用户创建项目需要哪些功能，然后获取到用户选择的功能以及配置
- 根据用户的选择合适的模版，进行渲染
- - 获取到用户选择模版的 package.json，合并构建输出的对应的package.json
- - 获取到用模版文件使用 ejs 进行渲染输出，ejs 能给根据用户的选择决定某些模块是否渲染
- - 使用 codemod 将相关的 options 和 import 插入到指定的文件。vuecodemod 将入口文件先转换成 ast，然后再 ast 中将相关的 import 和 options 插入到 AST 中，在将 ast 重新渲染
- 将渲染完的文件进行输出
- 运行安装命令


**函数式编程**

函数式编程作为声明式编程的一种形式，与命令式编程相对，命令式编程可以通过if-else控制流程，但函数式不能，所以需要函数组合子，组合子可以组合其他函数，组合子一般不包含变量和业务逻辑，他们的主要目的是管理函数的执行过程，并在链式调用中去处理中间结果，常见的组合子有compose、trycatch、map、reduce、filter、reverse、sort、curry。函数式编程来源于范畴论，最早是为了解决数学问题而诞生。范畴论认为，同一个范畴的所有成员，就是不同状态的"变形"，通过态射，一个成员可以变形成另一个成员。我们可以把物件理解为集合，态射理解为函数，通过函数，来规定范畴中成员之间的关系，函数扮演管道的角色，一个值进去，一个新值出来，没有其他副作用。函数不仅可以在用一个范畴之间转换，也能将一个范畴转换为另一个范畴。这就涉及到了函子。通常为了保证函数的尽可能纯粹性，副作用会使用函子进行统一管理。所谓的函子是函数式编程最基本的单位，它首先是一个范畴，包含了值和映射关系，它的映射关系就将当前函子转换为另一个函子，常见的有maybe菡子用于处理值为null的情况、either菡子用于错误处理，Either 函子有左值和右值，右值用来处理正常情况，左值用来处理异常情况、、IO 函子。它把不纯的操作（IO、网络请求、DOM）包裹在这个函数内，从而延迟这个操作的执行，相当于把这个副作用排到函子外部，这样函子是纯的。函数式风格包含了多种特性，典型的如函数一等公民、纯函数、副作用、柯里化、组合等。




**跨页面通信有多少种方式**

- 使用broadcastChannerl,BroadCast Channel 可以帮我们创建一个用于广播的通信频道，它的API和用法都非常简单。
- 使用service worker，Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Service Worker 可以共享。service worker本身不具备通信的功能，所以我们要做一定的改造，将其改造成消息中转站，在 Service Worker 中监听了message事件，获取页面发送的信息。然后获取当前注册了该 Service Worker 的所有页面，通过调用每个页面的postMessage方法，向页面发送消息。
- 使用localstorage，同时利用storage-event去监听 LocalStorage 变化。
- Shared Worker 是 Worker 家族的另一个成员。普通的 Worker 之间是独立运行、数据互不相通；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。
- 对于不同源的页面可以使用一个用户不可见的iframe作为桥，先利用post-message 向iframe发送消息，然后在让iframe利用上面的几种方式向同源的页面发送消息。


# babel

Babel 是一个工具链，主要用于在旧的浏览器或环境中将 ES6+的 代码转换为向后兼容版本的代码。主要有一下几个核心库，@babel/core 是整个 babel 的核心，它负责调度 babel 的各个组件来进行代码编译，是整个行为的组织者和调度者。@babel/preset-env，这是一个预设的插件集合，包含了一组相关的插件，Bable中是通过各种插件来指导如何进行代码转换。该插件包含所有的翻译规则，@babel/preset-env，可以根据选项参数来灵活地决定提供哪些插件，有三个关键的参数，target参数决定了我们项目需要适配到的环境,useBuiltIns决定 preset-env 如何处理 polyfills,一般使用usage， babel 会根据用户代码的使用情况，并根据 targets 自行注入相关 polyfills。corejs: corejs 并不是特殊概念,所有浏览器新 feature 的 polyfill 都会维护在 corejs-3。,@babel/preset-env只是提供了语法转换的规则，但是它并不能弥补浏览器缺失的一些新的功，此时就需要polyfill弥补低版本浏览器缺失的这些新功能。polyfill是在全局变量上挂载目标浏览器缺失的功能，因此在开发类库，第三方模块或者组件库时，就不能再使用babel-polyfill了，否则可能会造成全局污染，此时应该使用@babel/plugin-transform-runtime。transform-runtime的转换是非侵入性的，也就是它不会污染你的原有的方法。遇到需要转换的方法它会另起一个名字，否则会直接影响使用库的业务代码。我们在使用webpack打包js时，webpack并不知道应该怎么去调用这些规则去编译js。这时就需要babel-loader了，它作为一个中间桥梁，通过调用babel/core中的api来告诉webpack要如何处理js。

babel执行编译

- 首先是执行 normalizeFile 方法，该方法的作用就是将 code 转化为抽象语法树，JS 转换为 AST 的过程依赖于 @babel/parser，但如果我们需要自定义语法，或者是修改/扩展这些规则的时候，可以通过插件的方式自己写一个 parser 来覆盖默认的。

- 接着执行 transformFile 方法，该方法入参有我们的插件列表，使用 traverse 遍历 AST 节点，在遍历过程中执行插件。根据插件修改 AST 的内容。首先执行插件的 pre 方法，等待所有插件的 pre 方法都执行完毕后，在去执行visitor 中的方法，visitor会在遇到相应的节点或属性的时候才执行，为了优化，babel 将多个 visitor 合并成一个，最后执行插件的 post 方法。


```
module.exports = (babel) => {
  return {
    pre(path) {
      this.runtimeData = {}
    },
    visitor: {},
    post(path) {
      delete this.runtimeData
    }
  }
}

```

- AST 转换完毕后，需要将 AST 重新生成 code。@babel/generator 提供了默认的 generate 方法，生成目标代码





**weakmap、weakset、set、map的区别**

在开发的过程中，如果我们想让垃圾回收器回收一个对象，我们可以将这个对象的引用设置为null，这个时候就垃圾回收器就可以回收这个对象了，但是如果将一个对象设置为另外一个对象的属性或者值，这个时候在将前面那个对象设置为null，这样前面那个对象任然不可以被释放。所有当map的建值是对象的时候或者set储存了对象的时候，这个对象用完设置成null时是没办法使用的。所以有了weakmap,weakset

WeakSet 与 Set 的区别：

WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以
WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素

WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。
注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。
WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。


**nginx:**
nginx 在应用程序中的作用：解决跨域、请求过滤、配置 gzip和缓存、负载均衡、静态资源服务器

反向代理和正向代理

所谓的代理是指服务端和客户端之间有一层代理服务器，代理接受客户端的请求转发给服务端，然后将服务端的响应转发给客户端。代理分为正向代理和反向代理。所谓的正向代理是对客户端服务的，将客户端的请求代理到特定的机器上，对服务端来说他并不知道来自哪个机器上。反向代理是为服务器服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。对客户端来说并不知道他访问的是代理服务器，而服务器知道反向代理在为他服务。

nginx 的结构
- main:nginx的全局配置，对全局生效。
- events: 配置影响 nginx 服务器或与用户的网络连接。
- http：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。
- server：配置虚拟主机的相关参数，一个 http 中可以有多个 server。
- location：配置请求的路由，以及各种页面的处理情况。
- upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。


```
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

# Load dynamic modules. See /usr/share/nginx/README.dynamic.
include /usr/share/nginx/modules/*.conf;

events {
  worker_connections 1024;
}

http {
    server {
        listen 80;
        location  path {
            ...
        }
    }

    server {
        location  path {
            ...
        }
    }
}

```

配置负载均衡默认是轮询策略，将所有客户端请求轮询分配给服务端，这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。还可以配置最小连接数策略、最快响应时间策略、客户端 ip 绑定，来自同一个 ip的请求永远只分配一台服务器，有效解决了动态网页存在的 session 共享问题。

```
upstream balanceServer {
    server 10.1.22.33:12345;
    server 10.1.22.34:12345;
    server 10.1.22.35:12345;
}


server {
    server_name  fe.server.com;
    listen 80;
    location /api {
        proxy_pass http://balanceServer;
    }
}

```

**docker**

docker是一个虚拟容器，和普通的进程没什么区别，主要用来操作镜像，docker有几个重要的概念，第一个是镜像类似于虚拟机里面的快照，但比快照轻量多了，镜像是分层的，有基础镜像、中间件镜像、应用镜像，这三者之间依次叠加。所以当我们在构建镜像的时候每一个基础命令就是一个镜像层，书写命令的的时候能合并就合并。容器相当于镜像的实例化，应用是在容器中运行的，容器就是一个个独立的封闭的集装箱，但是也需要对外提供服务的，所以Docker允许公开容器的特定端口，在启动Docker的时候，我们就可以将容器的特定端口映射到宿主机上面的任意一个端口。仓库用来保存镜像。使用docker的好处主要有以下几种。
- 构建容易分发简单，只需要构建镜像文件，有了这个镜像，那么想复制到哪运行都可以，完全和平台无关了，不需要考虑环境。
- 同时Docker这种容器技术隔离出了独立的运行空间，不会和其他应用争用系统资源，所以不需要考虑应用之间相互影响。

```

启动docker容器
 docker run -d -p 2222:22 --name 容器名 镜像名
 -d 守护容器，就是后台运行，退出命令窗口容器也不会停止
 -it 交互式容器 退出命令窗口容器就停止运行了
 -p宿主机端口和容器端口映射
 8081:80 宿主机端口:容器公开的端口

```

**pnpm**
pnpm 本质上就是一个包管理器，这一点跟 npm/yarn 没有区别，相对于npm和yarn,pnpm安装包的速度更快，同时pnpm 内部使用基于内容寻址的文件系统来存储磁盘上所有的文件，而npm和yarn则是使用磁盘上的文件系统来存储所有的文件，所以不会重复安装同一个包，即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。他会将所有依赖包拍平,但他也有一些缺点，扁平化算法本身的复杂性很高，耗时较长,项目中仍然可以非法访问没有声明过依赖的包。


**服务端版本问题version**
版本的方案有三种：
 无版本——即平台的API永远只有一个版本，所有的用户都必须使用最新的API，任何API的修改都会影响到平台所有的用户。
 点对点，即平台的API版本自带版本号，用户根据自己的需求选择使用对应的API，需要使用新的API特性，用户必须自己升级
 兼容性版本控制，和The Knot一样，平台只有一个版本，但是最新版本需要兼容以前版本的API行为



**CDN**

CDN就是根据用户位置分配最近的资源,在没有应用CDN时，我们使用域名访问某一个站点时的路径为用户提交域名→浏览器对域名进行解释→DNS 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复,应用CDN后，DNS 返回的不再是 IP 地址，而是一个CNAME(Canonical Name ) 别名记录，指向CDN的全局负载均衡系统,CNAME实际上在域名解析的过程中承担了代理的角色，这是CDN实现的关键。由于没有返回IP地址，于是本地DNS会向负载均衡系统再发送请求 ，则进入到CDN的全局负载均衡系统进行智能调度，调度的策略有以下几种，看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点。看用户所在的运营商网络，找相同网络的边缘节点，检查边缘节点的负载情况，找负载较轻的节点，还有就是节点的“健康状况”、服务能力、带宽、响应时间等。结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问CDN的缓存代理。缓存系统是 CDN的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源，有两个衡量CDN服务质量的指标，命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比。回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比。缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户。回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源现在的商业 CDN命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上


**虚拟列表 list**

前端的业务开发中会遇到一些数据量较大且无法使用分页方式来加载的列表，我们一般把这种列表叫做长列表。

完整渲染的长列表基本上很难达到业务上的要求的，非完整渲染的长列表一般有两种方式：

懒渲染：这个就是常见的无限滚动的，每次只渲染一部分（比如 10 条），等剩余部分滚动到可见区域，就再渲染另一部分。
可视区域渲染：只渲染可见部分，不可见部分不渲染。
虚拟列表就是采用的可视区渲染方式优化。
虚拟列表（），是一种长列表优化方案，是可视区渲染列表。其两个重要的概念：

可滚动区域：假设有 1000 条数据，每个列表项的高度是 30，那么可滚动的区域的高度就是 1000 * 30。当用户改变列表的滚动条的当前滚动值的时候，会造成可见区域的内容的变更。
可见区域：比如列表的高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可见区域。
虚拟列表原理：

用数组保存所有列表元素的位置，只渲染可视区内的列表元素，当可视区滚动时，根据滚动的 offset 大小以及所有列表元素的位置，计算在可视区应该渲染哪些元素。

实现虚拟列表就是处理滚动条滚动后的可见区域的变更，具体实现步骤如下

计算当前可见区域起始数据的 startIndex
计算当前可见区域结束数据的 endIndex
计算当前可见区域的数据，并渲染到页面中
计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上


**会引起内存泄漏的几种方式**

- setTimeout首先就是个闭包，闭包可能会引起内存泄漏，同时setTimeOut返回的是一个全局的ID，这个id是在执行队列中排队的id,所以这个id代表事件句柄，会常驻在内存中。所以闭包在堆区，这个id在全局内存中，这两种情况都会造成内存泄漏。接近方式一是clear掉，第二种是把函数中引用的变量设置为null，第三种是使用weakmap把强引用变为弱引用。
- eval。webpack在开发环境中使用了eval，主要是为了快速打包，简单方便。在生产环境是没有eval的
- try catch 的e会延长作用域链，解决方式在新的js语法e可以不用写，这个e是全局的。
- new Function 也会造成放弃局部的gc
- promise一直处于pending的状态，会常驻内存也会造成内存泄漏。使用promise.race，添加一个定时执行的promise。
- 使用了比较大的全局变量。




