---
layout: post
title: ä¾èµ–æ³¨å…¥ä»¥åŠSOLID
subtitle: ä¾èµ–æ³¨å…¥
date: 2020-08-22
author: Qi
header-img: img/404-bg.jpg
catalog: true
tags:
  - ç¼–ç¨‹åŸºç¡€
---

# SOLOD
SOLIDæ˜¯æŒ‡å•ä¸€åŠŸèƒ½åŸåˆ™ã€å¼€é—­åŸåˆ™ã€é‡Œå¼æ›¿æ¢åŸåˆ™ã€æ¥å£éš”ç¦»ã€ä¾èµ–åè½¬ã€‚
- å•ä¸€åŠŸèƒ½åŸåˆ™ï¼ˆsï¼‰ï¼šæ˜¯æŒ‡ä¸€ä¸ªç±»åªåšä¸€ä¸ªç±»å‹çš„è´£ä»»ã€‚å½“è¿™ä¸ªç±»å‹éœ€è¦æ‰¿æ‹…å…¶ä»–ç±»å‹çš„è´£ä»»æ—¶ï¼Œå°±éœ€è¦åˆ†è§£è¿™ä¸ªç±»ã€‚å¸¸è§çš„æ–¹æ³•æ˜¯ä¸€ä¸ªå¤§ç±»å»å»ç®¡ç†å¤šä¸ªå°ç±»ã€‚æ¯”å¦‚USERç±»åˆ†åˆ«å»ç®¡ç†æ³¨å†Œç”¨æˆ·ç±»ã€ç™»å½•ç±»ç­‰
- å¼€é—­åŸåˆ™ï¼ˆO):æ‰€è°“çš„å¼€é—­åŸåˆ™æ˜¯æŒ‡ç±»æˆ–è€…æ¥å£çš„åŠŸèƒ½å¯ä»¥æ‰©å±•ï¼Œä½†ä¸èƒ½å»ä¿®æ”¹ã€‚
- é‡Œå¼æ›¿æ¢åŸåˆ™ï¼ˆLï¼‰ï¼šæ‰€è°“çš„é‡Œå¼æ›¿æ¢åŸåˆ™å°±æ˜¯å­ç±»å¯ä»¥æ›¿æ¢ä»–ä»¬çš„åŸºç±»ã€‚å¤§ç™½è¯å°±æ˜¯å­ç±»æ›¿ä»£çˆ¶ç±»ï¼Œä»£ç ä¸€æ ·èƒ½æ­£å¸¸è¿è¡Œ
- æ¥å£éš”ç¦»åŸåˆ™ï¼ˆIï¼‰ï¼šä¸èƒ½å¼ºè¿«ç”¨æˆ·å»ä¾èµ–é‚£äº›ä»–ä»¬ä¸ä½¿ç”¨çš„æ¥å£ï¼Œæ‰€ä»¥ä½¿ç”¨å¤šä¸ªä¸“é—¨çš„æ¥å£æ€»æ˜¯è¦å¥½äºä½¿ç”¨å•ä¸€çš„æ€»æ¥å£
- ä¾èµ–åè½¬ï¼ˆDï¼‰ï¼šé«˜å±‚æ¨¡å—ä¸èƒ½ä¾èµ–äºåº•å±‚æ¨¡å—ï¼ŒäºŒè€…éƒ½åº”è¯¥ä¾èµ–äºæŠ½è±¡ï¼ŒæŠ½è±¡æ¥å£ä¸èƒ½ä¾èµ–äºå…·ä½“çš„å®ç°ã€‚è€Œå…·ä½“çš„å®ç°åº”è¯¥ä¾èµ–äºæŠ½è±¡æ¥å£

# ä¾èµ–å€’ç½® DIP

ä¾èµ–å€’ç½®æ˜¯ä¸€ç§ç‰¹å®šçš„è§£è€¦æ–¹å¼ï¼Œä½¿å¾—é«˜å±‚æ¬¡çš„ä»£ç ä¸ä¾èµ–äºä½å±‚æ¬¡çš„å®ç°ï¼Œä¾èµ–å…³ç³»è¢«é¢ å€’ï¼ˆåè½¬ï¼‰ï¼Œä»è€Œä½¿å¾—ä½å±‚æ¬¡æ¨¡å—ä¾èµ–äºé«˜å±‚æ¬¡æ¨¡å—çš„éœ€æ±‚æŠ½è±¡ã€‚å…·ä½“çš„å®ç°åŸåˆ™å¦‚ä¸‹
- é«˜å±‚æ¬¡çš„ä»£ç ä¸åº”è¯¥ä¾èµ–äºä½å±‚æ¬¡çš„å®ç°ï¼Œä¸¤è€…éƒ½åº”è¯¥ä¾èµ–äºå…·ä½“çš„æ¥å£
- æŠ½è±¡æ¥å£ä¸èƒ½ä¾èµ–äºå…·ä½“çš„å®ç°ã€‚è€Œå…·ä½“çš„å®ç°åº”è¯¥ä¾èµ–äºæŠ½è±¡æ¥å£

# æ§åˆ¶åè½¬

æ§åˆ¶åè½¬æ˜¯é¢å‘å¯¹è±¡çš„ä¸€ç§è®¾è®¡æ–¹å¼ï¼Œç”¨æ¥é™ä½ä»£ç çš„è€¦åˆåº¦ã€‚æ˜¯å®ç°æ§åˆ¶åè½¬çš„ä¸€ç§è®¾è®¡æ€è·¯ã€‚å…¶ä¸­æœ€å¸¸è§çš„æ–¹å¼å«åšä¾èµ–æ³¨å…¥ï¼Œè¿˜æœ‰ä¸€ç§æ–¹å¼å«ä¾èµ–æŸ¥æ‰¾ã€‚

# ä¾èµ–æ³¨å…¥

ä¾èµ–æ³¨å…¥æ˜¯å®ç°æ§åˆ¶åè½¬çš„ä¸€ç§æ–¹å¼ï¼Œå¸¸è§çš„æœ‰æ¥å£æ³¨å…¥ã€æ„é€ å‡½æ•°æ³¨å…¥ã€å‚æ•°æ³¨å…¥

# æ¡ˆä¾‹ä»‹ç»

å¸¸ç”¨çš„åç«¯æ¶æ„å¯ä»¥åˆ†ä¸º 3 å±‚ï¼š

- controllerå±‚:æ¥æ”¶å‰ç«¯è¯·æ±‚ï¼Œå¤„ç†è¯·æ±‚å‚æ•°ï¼ŒåŒ¹é…åç«¯è·¯ç”±ï¼Œè°ƒç”¨å¯¹åº”çš„ service å±‚å¤„ç†ä¸šåŠ¡ã€‚
- serviceå±‚ï¼šæ¥æ”¶ controller å±‚çš„å‚æ•°ï¼Œå¤„ç†ä¸šåŠ¡é€»è¾‘ï¼Œå¦‚æœéœ€è¦è¯»å–æ•°æ®ï¼Œä¼šè°ƒç”¨ model å±‚
- modelå±‚ï¼šå¤„ç†æ•°æ®åº“ç›¸å…³çš„å±‚ï¼Œè´Ÿè´£è¿æ¥æ•°æ®åº“ï¼Œä»¥åŠå¸¸ç”¨çš„å¢åˆ æ”¹æŸ¥æ–¹æ³•çš„å°è£…

# éä¾èµ–æ³¨å…¥çš„å¼€å‘æ¨¡å¼

éä¾èµ–æ³¨å…¥çš„å¼€å‘æ¨¡å¼å¾ˆç¬¦åˆå¸¸è§„é€»è¾‘ï¼Œå°±æ˜¯controllerå±‚ä¾èµ–serviceå±‚ï¼Œserviceå±‚ä¾èµ–äºmodelå±‚ã€‚è¿™æ˜¯å…¸å‹çš„é«˜å±‚ä»£ç ä¾èµ–äºåº•å±‚çš„ä»£ç 

```
// æ¡ˆä¾‹ä¸­ä½¿ç”¨ä¼ªä»£ç ï¼Œä¾¿äºå¤§å®¶ç†è§£ã€‚
class Model {
  select(sql) {
    const mysql = require('mysql');
    return new Promise(resolve => {
      // è¿æ¥æ•°æ®åº“ï¼Œå¹¶æ‰§è¡Œ sql è¯­å¥è¿›è¡ŒæŸ¥è¯¢
      mysql.createConnection().query(sql, (error, results, fields) => {
        const success = results.length > 0 ? true : false;
        resolve(success);
      });
    });
  }
}

class Service {
  async login(username, password) {
    const db = new Model();
    const success = await db.select(
      `select * from user where username=${username} and password=${password}`
    );
    return success ? 'ç™»å½•æˆåŠŸ' : 'ç™»å½•å¤±è´¥';
  }
}

class Controller {
  matchRouter(path) {
    switch (path) {
      case 'login':
        const service = new Service();
        const { username, password } = path.query;
        return service.login(username, password);
    }
  }
}

```
éä¾èµ–æ³¨å…¥å¼€å‘æ¨¡å¼çš„ä¼˜ç¼ºç‚¹ï¼š
- ä»£ç å¤æ‚åº¦ä½ï¼Œé€»è¾‘æ¸…æ™°ï¼Œä½¿ç”¨æ–¹ä¾¿ï¼Œç›´æ¥ new æœ€ä¸Šå±‚çš„æ¨¡å—å°±è¡Œäº†ã€‚
- ä¸åˆ©äºç»´æŠ¤ï¼Œå¦‚æœåº•å±‚ï¼ˆ model å±‚ï¼‰ä¿®æ”¹äº† select æ–¹æ³•çš„ä¼ å‚æ–¹å¼ï¼Œä¸Šå±‚ï¼ˆservice å±‚å’Œ controller å±‚ï¼‰ä¹Ÿå¿…é¡»åŒæ­¥ä¿®æ”¹è°ƒç”¨æ–¹å¼ã€‚
- ä¸åˆ©äºæµ‹è¯•ï¼Œå„ä¸ªæ¨¡å—è€¦åˆåœ¨ä¸€èµ·ï¼Œè¦å•ç‹¬æµ‹è¯• controller å±‚æ˜¯ä¸è¡Œçš„ï¼Œå› ä¸ºå®ƒå†…éƒ¨å¼•å…¥äº† service å±‚å’Œ model å±‚ï¼Œåªèƒ½å½“æˆä¸€ä¸ªæ•´ä½“æµ‹è¯•ã€‚




# ä¾èµ–æ³¨å…¥çš„å¼€å‘æ¨¡å¼

å¦‚æœæŠŠä¸Šé¢çš„æ¡ˆä¾‹æ”¹é€ æˆä¾èµ–æ³¨å…¥çš„æ–¹å¼ä¹Ÿå¾ˆç®€å•ï¼Œåˆ é™¤å†…éƒ¨ä¾èµ–å…³ç³»ï¼Œå°†éœ€è¦çš„ä¾èµ–é€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥å°±è¡Œäº†ã€‚
```
// æ¡ˆä¾‹ä¸­ä½¿ç”¨ä¼ªä»£ç ï¼Œä¾¿äºå¤§å®¶ç†è§£ã€‚
class Model {
  select(sql) {
    const mysql = require('mysql');
    return new Promise(resolve => {
      // è¿æ¥æ•°æ®åº“ï¼Œå¹¶æ‰§è¡Œ sql è¯­å¥è¿›è¡ŒæŸ¥è¯¢
      mysql.createConnection().query(sql, (error, results, fields) => {
        const success = results.length > 0 ? true : false;
        resolve(success);
      });
    });
  }
}

class Service {
  constructor(db) {
    this.db = db;
  }
  async login(username, password) {
    // const db = new Model();
    const success = await this.db.select(
      `select * from user where username=${username} and password=${password}`
    );
    return success ? 'ç™»å½•æˆåŠŸ' : 'ç™»å½•å¤±è´¥';
  }
}

class Controller {
  constructor(service) {
    this.service = service;
  }
  matchRouter(path) {
    switch (path) {
      case 'login':
        // const service = new Service();
        const { username, password } = path.query;
        return this.service.login(username, password);
    }
  }
}

// ä½¿ç”¨ controller å±‚ä¹‹å‰ï¼Œå¿…é¡»æ‰‹åŠ¨åˆ›å»ºä¾èµ–ï¼Œå¹¶æ³¨å…¥
const model = new Model();
const service = new Service(model);
const controller = new Controller(service);
controller.matchRouter('login');

```

web å±‚å¹¶ä¸ç›´æ¥ä¾èµ– service å±‚ï¼Œè€Œæ˜¯é€šè¿‡æ„é€ å‡½æ•°å°† service ä¼ è¿›æ¥ç›´æ¥ç”¨ï¼Œè¿™å°±å®ç°äº†ä¾èµ–æ³¨å…¥çš„æ•ˆæœã€‚

ä¾èµ–æ³¨å…¥å¼€å‘æ¨¡å¼çš„ä¼˜ç¼ºç‚¹ï¼š

- ä»£ç å¤æ‚åº¦ä½ï¼Œé€»è¾‘æ¸…æ™°ï¼Œä½¿ç”¨è¾ƒå¤æ‚ï¼Œéœ€è¦æ‰‹åŠ¨æ³¨å…¥ä¾èµ–ã€‚
- ä¾¿äºç»´æŠ¤ï¼Œä»£ç è€¦åˆåº¦ä½ï¼Œå„ä¸ªæ¨¡å—äº’ä¸ä¾èµ–
- ä¾¿äºæµ‹è¯•ï¼Œä¸åŒæ¨¡å—ä¹‹é—´å¯ä»¥å•ç‹¬çš„è¿›è¡Œå•å…ƒæµ‹è¯•ã€‚

# ä¾èµ–æ³¨å…¥å®¹å™¨çš„å¼€å‘æ¨¡å¼

å¦‚æœä½¿ç”¨ä¸Šé¢çš„æ¡ˆä¾‹ï¼Œæ¯ä¸€æ¬¡ä½¿ç”¨éƒ½éœ€è¦æ‰‹åŠ¨ä¼ å…¥ä¾èµ–ï¼Œå½“ä¾èµ–å¤ªå¤šæ—¶ï¼Œä¹Ÿä¼šé€ æˆéš¾ä»¥ç»´æŠ¤çš„é—®é¢˜ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ªåœ°æ–¹ç»Ÿä¸€è¿›è¡Œä¾èµ–æ³¨å…¥ï¼Œå³åœ¨ä¸€ä¸ªä¾èµ–æ³¨å…¥å®¹å™¨é‡Œã€‚

IOCçš„å®ç°:

**CreateIoc**
- åˆ›å»ºIOCçš„containerï¼Œç”¨æ¥å­˜å‚¨ç›¸å…³çš„ä¾èµ–ã€‚
- getæ˜¯ä¸ºäº†è·å–ä¾èµ–
- bindæ˜¯å°†å¯¹åº”çš„ä¾èµ–æ·»åŠ è¿›container
```
class CreateIoc{
    public container:Map<Symbol,{callback:Function}>;
    constructor(){
        this.container=new Map();
    }
    get(namespace:Symbol){
        let item=this.container.get(namespace);
        return item?.callback()
        
    }
    bind(namespace:Symbol,callback:Function){
        if(namespace&&callback){
            this.container.set(namespace,{callback})
        } 
    }
}
export default CreateIoc

```

**æ³¨å…¥çš„å…·ä½“å®ç°è¿‡ç¨‹**

- åˆ©ç”¨è£…é¥°å™¨å¯¹controllerçš„contstructorè¿›è¡ŒåŠ«æŒï¼Œåˆ©ç”¨astè·å–åˆ°constructorçš„å…·ä½“å‚æ•°
- ç„¶ååˆ©ç”¨Reflect.getMetadataå°†ç›¸å…³çš„å‚æ•°å±æ€§æŒ‚è½½åˆ°constructorçš„å…ƒçº§ä¸Šã€‚

```
function controller<T extends { new(...args: any[]): {} }>(constructor: T) {
    class Controller extends constructor{
        constructor(...args:any[]){
            super(args)
             //ç”¨ASTåˆ†æconstructorï¼Œè·å–constructorçš„å‚æ•°
             const params = getParams(constructor);
             let identity: string;
             for (identity of params) {
                 if (hasKey(this, identity)) {
                    this[identity] = Reflect.getMetadata(Types[identity], constructor)
                    console.log('aaaa',this[identity])
                 } else {
                     throw new Error(identity);
                 }
             }
        }
    }
    return Controller
}

//Patternæ˜¯ä¸ªastçš„åº“ï¼ŒparseSriptæ˜¯è§£ææˆast
function getParams(constructor:Function){
    const ast=parseScript(constructor.toString())
    let node = ast.body[0];
    let funParams: Pattern[] = [];
    if(node.type==='FunctionDeclaration'){
        funParams=node.params;
    }
    let validParams: string[] = [];
    funParams.forEach(obj=>{
        if (obj.type === "Identifier") {
            validParams.push(obj.name);
        }
    })
    return validParams
}

```

- åˆ©ç”¨å‚æ•°è£…é¥°å™¨å¯¹å‚æ•°è¿›è¡ŒåŠ«æŒï¼Œæ ¹æ®å‚æ•°è·å–åˆ°å¯¹åº”çš„serive,ç„¶åè¿›è¡Œå…ƒçº§çš„å®šä¹‰


```
function inject(serviceIdentifier:Symbol){
    console.log(serviceIdentifier,'ss')
    return function(target:Function,targetKey:string,index:number){
        if(!targetKey){
            Reflect.defineMetadata(serviceIdentifier,container.get(serviceIdentifier),target)
        }
    }
}

```

**æœ€ç»ˆå®ç°**

```
import { parseScript } from "esprima";
import Container from './ioc'
import { Pattern } from "estree";
import "reflect-metadata";
const container=new Container();

interface IindexService {
    info(str: string): void;
}

interface ITypes{
    [key:string]:Symbol
}

const Types: ITypes = {
    indexService:Symbol.for('indexService')
}
class indexService implements IindexService{
    public info(info:string){
        console.log(info)
    }
}

function getParams(constructor:Function){
    const ast=parseScript(constructor.toString())
    let node = ast.body[0];
    let funParams: Pattern[] = [];
    if(node.type==='FunctionDeclaration'){
        funParams=node.params;
    }
    let validParams: string[] = [];
    funParams.forEach(obj=>{
        if (obj.type === "Identifier") {
            validParams.push(obj.name);
        }
    })
    return validParams
}
function hasKey<T extends Object>(obj:T,key:keyof any):key is keyof T{
    return obj.hasOwnProperty(key)
}
container.bind(Types.indexService,()=>new indexService())
//constructoræŒ‡å‘contructorçš„constructor,constructoråˆæŒ‡å‘controller
//T extendsç”¨æ¥é™èŒƒå›´ï¼Œé™å®šä¸ºæ„é€ å‡½æ•°
function controller<T extends { new(...args: any[]): {} }>(constructor: T) {
    class Controller extends constructor{
        constructor(...args:any[]){
            super(args)
             //ç”¨ASTåˆ†æconstructorï¼Œè·å–constructorçš„å‚æ•°
             const params = getParams(constructor);
             let identity: string;
             for (identity of params) {
                 if (hasKey(this, identity)) {
                    this[identity] = Reflect.getMetadata(Types[identity], constructor)
                    console.log('aaaa',this[identity])
                 } else {
                     throw new Error(identity);
                 }
             }
        }
    }
    return Controller
}

function inject(serviceIdentifier:Symbol){
    console.log(serviceIdentifier,'ss')
    return function(target:Function,targetKey:string,index:number){
        if(!targetKey){
            Reflect.defineMetadata(serviceIdentifier,container.get(serviceIdentifier),target)
        }
    }
}

@controller
class IndexController {
    public indexService: IindexService;
    constructor(@inject(Types.indexService)indexService:any){
        this.indexService=indexService
    }
    info(log:string){
       this.indexService.info(log)
    }
}

const indexController=new IndexController(null);
indexController.info('sssssğŸŠ')
```

# ä¾èµ–æ³¨å…¥-awilix

awilixæ˜¯ç”¨äºJavaScript / Nodeçš„åŠŸèƒ½å¼ºå¤§çš„Dependency Injectionï¼ˆDIï¼‰å®¹å™¨ï¼Œä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼š


- åˆ›å»ºä¸€ä¸ªå®¹å™¨
```
const awilix = require('awilix')

const container = awilix.createContainer({
  injectionMode: awilix.InjectionMode.PROXY
})

```
- åœ¨å®¹å™¨ä¸­æ³¨å†Œæ¨¡å—,resolveå¹¶ä½¿ç”¨

```
class UserController {
  // We are using constructor injection.
  constructor(opts) {
    // Save a reference to our dependency.
    this.userService = opts.userService
  }

  // imagine ctx is our HTTP request context...
  getUser(ctx) {
    return this.userService.getUser(ctx.params.id)
  }
}

container.register({
  // Here we are telling Awilix how to resolve a
  // userController: by instantiating a class.
  userController: awilix.asClass(UserController)
})

container.register({
  // the `userService` is resolved by
  // invoking the function.
  userService: awilix.asFunction(makeUserService)
})


function Database(connectionString, timeout) {
  // We can inject plain values as well!
  this.conn = connectToYourDatabaseSomehow(connectionString, timeout)
}

Database.prototype.query = function(sql) {
  // blah....
  return this.conn.rawSql(sql)
}

container.register({
  db: awilix.asClass(Database).classic()
})

container.register({
  // We can register things as-is - this is not just
  // limited to strings and numbers, it can be anything,
  // really - they will be passed through directly.
  connectionString: awilix.asValue(process.env.CONN_STR),
  timeout: awilix.asValue(1000)
})

router.get('/api/users/:id', container.resolve('userController').getUser)


router.get('/api/users/:id', container.cradle.userController.getUser)

```

# InversifyJS

InversifyJSæ˜¯TypeScriptå’ŒJavaScriptåº”ç”¨ç¨‹åºçš„è½»é‡çº§æ§ä»¶åè½¬ï¼ˆIoCï¼‰å®¹å™¨ã€‚IoCå®¹å™¨ä½¿ç”¨ç±»æ„é€ å‡½æ•°æ¥æ ‡è¯†å’Œæ³¨å…¥å…¶ä¾èµ–é¡¹ã€‚InversifyJSå…·æœ‰å‹å¥½çš„APIï¼Œå¹¶é¼“åŠ±ä½¿ç”¨æœ€ä½³çš„OOPå’ŒIoCåšæ³•ã€‚InversifyJSçš„å¼€å‘å…·æœ‰å››ä¸ªä¸»è¦ç›®æ ‡
- å…è®¸JavaScriptå¼€å‘äººå‘˜ç¼–å†™ç¬¦åˆSOLIDåŸåˆ™çš„ä»£ç ã€‚
- ä¿ƒè¿›å¹¶é¼“åŠ±éµå®ˆæœ€ä½³OOPå’ŒIoCæƒ¯ä¾‹ã€‚
- å°½å¯èƒ½å‡å°‘è¿è¡Œæ—¶å¼€é”€ã€‚
- æä¾›æœ€æ–°çš„å¼€å‘ç»éªŒã€‚

**InversifyJsçš„ä½¿ç”¨æ¡ä»¶**
- InversifyJså¿…é¡»è¦æ±‚TypeScript >= 2.0 ï¼Œå¹¶ä¸”tsconfig.jsonå…·å¤‡å¦‚ä¸‹é…ç½®

```
{
    "compilerOptions": {
        "target": "es5",
        "lib": ["es6"],
        "types": ["reflect-metadata"],
        "module": "commonjs",
        "moduleResolution": "node",
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true
    }
}

```

- InversifyJSéœ€è¦å…·æœ‰ä»¥ä¸‹åŠŸèƒ½çš„ç°ä»£JavaScriptå¼•æ“ï¼Œå¦‚æœä¸æ”¯æŒéœ€è¦è¿›è¡Œpolyfill

```
Reflect metadata
Map
Promise (Only required if using provider injection)
Proxy (Only required if using activation handlers)
```

**InversifyJSä½¿ç”¨æ­¥éª¤**
- å£°æ˜interfaceså’ŒTypes

å£°æ˜æ¥å£ä¸»è¦æ˜¯ä¸ºäº†éµå®ˆä¾èµ–åè½¬åŸåˆ™ï¼Œä¾èµ–æŠ½è±¡ä¸èƒ½ä¾èµ–å…·ä½“çš„å®ç°ã€‚
```
export interface Warrior {
    fight(): string;
    sneak(): string;
}

export interface Weapon {
    hit(): string;
}

export interface ThrowableWeapon {
    throw(): string;
}

```
å£°æ˜Typesä¸»è¦æ˜¯ä¸ºäº†ç”¨ä½œè¿è¡Œæ—¶ä½œä¸ºç±»å‹çš„æ ‡è¯†ç¬¦ï¼Œæˆ‘ä»¬ä½¿ç”¨Symbolä½œä¸ºæ ‡è¯†ç¬¦ï¼Œä½†æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»å’Œ/æˆ–å­—ç¬¦ä¸²æ–‡å­—ã€‚æ¨èSymbol

```
const TYPES = {
    Warrior: Symbol.for("Warrior"),
    Weapon: Symbol.for("Weapon"),
    ThrowableWeapon: Symbol.for("ThrowableWeapon")
};

export { TYPES };

```

- ä½¿ç”¨@injectableï¼†@injectè£…é¥°å™¨å£°æ˜ä¾èµ–é¡¹

å½“ä¸€ä¸ªç±»å¯¹æ¥å£æœ‰ä¾èµ–æ€§æ—¶ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä½¿ç”¨@injectè£…é¥°å™¨ä¸ºè¯¥æ¥å£å®šä¹‰ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œè¯¥æ ‡è¯†ç¬¦å°†åœ¨è¿è¡Œæ—¶å¯ç”¨ã€‚

```
import { injectable, inject } from "inversify";
import "reflect-metadata";
import { Weapon, ThrowableWeapon, Warrior } from "./interfaces";
import { TYPES } from "./types";

@injectable()
class Katana implements Weapon {
    public hit() {
        return "cut!";
    }
}

@injectable()
class Shuriken implements ThrowableWeapon {
    public throw() {
        return "hit!";
    }
}

@injectable()
class Ninja implements Warrior {

    private _katana: Weapon;
    private _shuriken: ThrowableWeapon;

    public constructor(
	    @inject(TYPES.Weapon) katana: Weapon,
	    @inject(TYPES.ThrowableWeapon) shuriken: ThrowableWeapon
    ) {
        this._katana = katana;
        this._shuriken = shuriken;
    }

    public fight() { return this._katana.hit(); }
    public sneak() { return this._shuriken.throw(); }

}

export { Ninja, Katana, Shuriken };
```
ä¹Ÿå¯ä»¥ä½¿ç”¨å±æ€§æ³¨å…¥ï¼Œä¸ä½¿ç”¨æ„é€ å‡½æ•°æ³¨å…¥

```
@injectable()
class Ninja implements Warrior {
    @inject(TYPES.Weapon) private _katana: Weapon;
    @inject(TYPES.ThrowableWeapon) private _shuriken: ThrowableWeapon;
    public fight() { return this._katana.hit(); }
    public sneak() { return this._shuriken.throw(); }
}
```

- åˆ›å»ºå’Œé…ç½®å®¹å™¨

åˆ›å»ºinversify.config.tsï¼Œæ˜¯å”¯ä¸€å­˜åœ¨è€¦åˆçš„åœ°æ–¹ã€‚åœ¨åº”ç”¨ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†ï¼Œæ‚¨çš„ç±»åº”è¯¥æ²¡æœ‰å¯¹å…¶ä»–ç±»çš„å¼•ç”¨ã€‚

```
import { Container } from "inversify";
import { TYPES } from "./types";
import { Warrior, Weapon, ThrowableWeapon } from "./interfaces";
import { Ninja, Katana, Shuriken } from "./entities";

const myContainer = new Container();
myContainer.bind<Warrior>(TYPES.Warrior).to(Ninja);
myContainer.bind<Weapon>(TYPES.Weapon).to(Katana);
myContainer.bind<ThrowableWeapon>(TYPES.ThrowableWeapon).to(Shuriken);

export { myContainer };
```

- è§£å†³ä¾èµ–å…³ç³»
ä½¿ç”¨è¯¥æ–¹æ³•get<T>ä»Containerç±»æ¥è§£å†³ä¾èµ–ã€‚

```
import { myContainer } from "./inversify.config";
import { TYPES } from "./types";
import { Warrior } from "./interfaces";

const ninja = myContainer.get<Warrior>(TYPES.Warrior);
```







